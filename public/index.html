<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Hull Cleaning Constraints Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" crossorigin="" />
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <style>
    /* [CSS remains unchanged from original] */
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: Arial, sans-serif;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    #sidebar {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1000;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      max-width: 350px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .constraint-group {
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #eee;
    }

    .constraint-group h4 {
      margin: 5px 0;
      color: #333;
    }

    .layer-control {
      margin: 5px 0;
    }

    .layer-control label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      font-size: 0.9em;
    }

    .layer-control-loading {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .layer-control-loading:after {
      content: " (loading...)";
      font-style: italic;
      color: #666;
    }

    .legend {
      margin-top: 20px;
      padding-top: 10px;
      border-top: 2px solid #ccc;
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin: 5px 0;
      font-size: 0.85em;
    }

    .legend-color {
      width: 20px;
      height: 20px;
      margin-right: 8px;
      border: 1px solid #999;
      border-radius: 3px;
    }

    .info-text {
      font-size: 0.9em;
      color: #666;
      margin: 10px 0;
      padding: 10px;
      background: #f5f5f5;
      border-radius: 4px;
    }

    #loadingOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 3000;
      font-family: sans-serif;
      text-align: center;
      padding: 20px;
    }

    .spinner {
      border: 8px solid #f3f3f3;
      border-top: 8px solid #673AB7;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    .dot-animation:after {
      content: '.';
      animation: dots 1.5s steps(5, end) infinite;
    }

    @keyframes dots {

      0%,
      20% {
        content: '.';
      }

      40% {
        content: '..';
      }

      60% {
        content: '...';
      }

      80%,
      100% {
        content: '';
      }
    }

    #loadingMessage {
      font-size: 1.1em;
      color: #333;
    }

    #loadingSubMessage {
      font-size: 0.85em;
      color: #666;
      margin-top: 10px;
      max-width: 80%;
    }

    #progressBar {
      width: 80%;
      max-width: 300px;
      height: 10px;
      background-color: #f3f3f3;
      border-radius: 5px;
      margin-top: 15px;
      overflow: hidden;
    }

    #progressFill {
      height: 100%;
      width: 0%;
      background-color: #673AB7;
      transition: width 0.5s ease;
    }

    #analysisContainer {
      display: none;
      position: fixed;
      left: 20px;
      bottom: 20px;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      max-width: 400px;
      max-height: 60vh;
      overflow-y: auto;
      z-index: 1500;
    }

    #analysisClose {
      position: absolute;
      top: 10px;
      right: 10px;
      cursor: pointer;
      font-size: 18px;
      color: #666;
    }

    #analysisContent {
      margin-top: 10px;
    }

    .analysis-item {
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid #eee;
    }

    .analysis-item:last-child {
      border-bottom: none;
    }

    .analysis-header {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }

    .analysis-icon {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .analysis-title {
      font-weight: bold;
      font-size: 0.95em;
    }

    .analysis-detail {
      margin-left: 20px;
      font-size: 0.85em;
      color: #555;
    }

    .analysis-warning {
      color: #e53935;
      font-weight: bold;
    }

    .analysis-good {
      color: #43a047;
      font-weight: bold;
    }

    .nautical-reference {
      font-size: 0.9em;
      background-color: #f0f8ff;
      padding: 6px;
      margin-bottom: 6px;
      border-left: 3px solid #0066CC;
    }

    #errorToast {
      display: none;
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #f44336;
      color: white;
      padding: 12px 20px;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      z-index: 3100;
      font-size: 14px;
    }

    .analysis-marker {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: rgba(103, 58, 183, 0.8);
      color: white;
      font-weight: bold;
      border: 2px solid white;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    }

    .navigation-aids,
    .vessel-icon,
    .weather-icon,
    .warning-icon,
    .depth-label,
    .sea-mark-icon {
      background: transparent;
      border: none;
    }

    .depth-label {
      font-weight: bold;
      text-shadow: 0px 0px 2px white;
    }

    .sea-mark-icon {
      filter: drop-shadow(0px 0px 1px white);
    }

    #serverStatus {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.8);
      padding: 5px 10px;
      border-radius: 15px;
      font-size: 12px;
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
    }

    .status-connecting {
      background-color: #FFA000;
    }

    .status-online {
      background-color: #4CAF50;
    }

    .status-offline {
      background-color: #F44336;
    }

    .status-degraded {
      background-color: #FF9800;
    }

    .retry-button {
      background-color: #673AB7;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 16px;
      font-size: 14px;
      cursor: pointer;
      margin-top: 15px;
    }

    .retry-button:hover {
      background-color: #5E35B1;
    }

    .layer-control-error {
      opacity: 0.8;
      background-color: #fff5f5;
      border-radius: 4px;
      padding: 2px 4px;
    }

    .layer-control-error:after {
      content: " (error)";
      font-style: italic;
      color: #e53935;
    }

    .layer-error-message {
      font-size: 0.8em;
      color: #e53935;
      margin-left: 24px;
      font-style: italic;
    }

    .layer-retry-button {
      margin-left: 24px;
      font-size: 0.8em;
      background-color: #673AB7;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 2px 6px;
      cursor: pointer;
      margin-top: 2px;
    }

    .layer-retry-button:hover {
      background-color: #5E35B1;
    }

    .depth-contour-5 {
      color: #a5ddff;
      stroke: #a5ddff;
      stroke-width: 2px;
    }

    .depth-contour-10 {
      color: #77c3ec;
      stroke: #77c3ec;
      stroke-width: 2px;
    }

    .depth-contour-15 {
      color: #5ba3d0;
      stroke: #5ba3d0;
      stroke-width: 2px;
    }

    .depth-contour-20 {
      color: #3d83b3;
      stroke: #3d83b3;
      stroke-width: 2px;
    }

    .depth-contour-30 {
      color: #2064a0;
      stroke: #2064a0;
      stroke-width: 2px;
    }

    .depth-contour-50 {
      color: #1a4989;
      stroke: #1a4989;
      stroke-width: 2px;
    }

    .buoy-port {
      color: #FF0000;
      font-size: 22px;
    }

    .buoy-starboard {
      color: #00AA00;
      font-size: 22px;
    }

    .lighthouse {
      color: #000000;
      font-size: 22px;
    }

    .anchorage {
      color: #0066CC;
      font-size: 20px;
    }

    .danger {
      color: #FF0000;
      font-size: 20px;
    }

    .calculation-status {
      background: #f5f8ff;
      border-left: 4px solid #673AB7;
      padding: 8px 12px;
      margin: 8px 0;
      font-size: 13px;
      border-radius: 0 4px 4px 0;
    }

    .calculation-progress {
      font-weight: bold;
      color: #673AB7;
    }

    .calculation-time {
      font-size: 12px;
      color: #666;
      margin-top: 4px;
    }

    #successToast {
      display: none;
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #4CAF50;
      color: white;
      padding: 12px 20px;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      z-index: 3100;
      font-size: 14px;
    }
  </style>
</head>

<body>
  <div id="loadingOverlay">
    <div class="spinner"></div>
    <div id="loadingMessage" class="dot-animation">Loading marine data</div>
    <div id="loadingSubMessage">This map is running on a free server which may take a minute to wake up if it hasn't
      been used recently. Thank you for your patience.</div>
    <div id="progressBar">
      <div id="progressFill"></div>
    </div>
  </div>
  <div id="errorToast"></div>
  <div id="successToast"></div>
  <div id="analysisContainer">
    <span id="analysisClose">×</span>
    <h3>Location Analysis</h3>
    <div id="analysisContent"></div>
  </div>
  <div id="confirmationModal"
    style="display: none; position: fixed; z-index: 2500; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5);">
    <div
      style="background-color: white; margin: 15% auto; padding: 20px; border-radius: 8px; width: 300px; text-align: center; box-shadow: 0 4px 8px rgba(0,0,0,0.2);">
      <h4 style="margin-top: 0;">Location Analysis</h4>
      <p>Would you like to generate a report for this location?</p>
      <div style="display: flex; justify-content: center; gap: 10px;">
        <button id="confirmYes"
          style="padding: 8px 16px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Yes</button>
        <button id="confirmNo"
          style="padding: 8px 16px; background-color: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">No</button>
      </div>
    </div>
  </div>
  <div id="map"></div>
  <div id="sidebar">
    <h3>Hull Cleaning Constraints</h3>
    <div class="info-text">
      To select potential cleaning sites, ensure the location:
      <ul>
        <li>Is outside Fremantle Port limits</li>
        <li>Has minimal proximity to sensitive receptors (marine parks, fish habitat, Cockburn Sound protection, etc.)
        </li>
        <li>Offers sufficient water flow for safe dispersion of residuals</li>
      </ul>
      Areas shown in the "Potential Cleaning Zones" layer represent parts of the study area that do not intersect with
      restricted zones and are only in water areas.
      <p><em>Click anywhere on the map to analyze a potential cleaning location.</em></p>
      <button id="forceClearCalculation"
        style="background-color: #F44336; color: white; padding: 8px 16px; border: none; border-radius: 4px; margin-top: 10px; cursor: pointer;">Clear
        Cache & Recalculate</button>
    </div>
    <div class="constraint-group">
      <h4>Jurisdictional</h4>
      <div class="layer-control layer-control-loading">
        <label><input type="checkbox" id="portAuthoritiesCheckbox" checked> Port Authority Areas</label>
      </div>
    </div>
    <div class="constraint-group">
      <h4>Environmental Protection</h4>
      <div class="layer-control layer-control-loading">
        <label><input type="checkbox" id="marineParksCheckbox" checked> Marine Parks & Reserves</label>
      </div>
      <div class="layer-control layer-control-loading">
        <label><input type="checkbox" id="fishHabitatCheckbox" checked> Fish Habitat Protection Areas</label>
      </div>
      <div class="layer-control layer-control-loading">
        <label><input type="checkbox" id="cockburnSoundCheckbox" checked> Cockburn Sound Protection Area</label>
      </div>
    </div>
    <div class="constraint-group">
      <h4>Infrastructure & Restricted Areas</h4>
      <div class="layer-control layer-control-loading">
        <label><input type="checkbox" id="mooringAreasCheckbox" checked> Mooring Control Areas</label>
      </div>
      <div class="layer-control layer-control-loading">
        <label><input type="checkbox" id="marineInfrastructureCheckbox" checked> Marine Infrastructure</label>
      </div>
      <div class="layer-control layer-control-loading">
        <label><input type="checkbox" id="marineGeomorphicCheckbox" checked> Marine Geomorphic Features</label>
      </div>
    </div>
    <div class="constraint-group">
      <h4>Recommended Cleaning Zones</h4>
      <div class="layer-control layer-control-loading">
        <label><input type="checkbox" id="recommendedZonesCheckbox" checked> Potential Cleaning Zones</label>
      </div>
      <div id="zoneCalculationStatus" class="calculation-status" style="display: none;">
        <div>Calculating recommended zones: <span id="calculationProgress" class="calculation-progress">0%</span></div>
        <div id="calculationTime" class="calculation-time"></div>
      </div>
    </div>
    <div class="constraint-group">
      <h4>Nautical Overlays</h4>
      <div class="layer-control layer-control-loading">
        <label><input type="checkbox" id="navigationAidsCheckbox" checked> Navigation Aids</label>
      </div>
      <div class="layer-control">
        <label><input type="checkbox" id="marineTrafficCheckbox"> Marine Traffic (AIS)</label>
      </div>
      <div class="layer-control">
        <label><input type="checkbox" id="weatherCheckbox"> Weather & Wind</label>
      </div>
      <div class="layer-control">
        <label><input type="checkbox" id="navigationalWarningsCheckbox"> Navigational Warnings</label>
      </div>
      <div class="layer-control layer-control-loading">
        <label><input type="checkbox" id="bathymetryCheckbox" checked> Bathymetry (Depth Contours)</label>
      </div>
      <div class="layer-control layer-control-loading">
        <label><input type="checkbox" id="marineMultibeamCheckbox"> High-Resolution Bathymetry</label>
      </div>
    </div>
    <div class="legend">
      <h4>Legend</h4>
      <div class="legend-item">
        <div class="legend-color" style="background: #FF4081"></div> Port Authority Areas
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #4CAF50"></div> Marine Parks & Reserves
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #FF9800"></div> Fish Habitat Areas
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #2196F3"></div> Cockburn Sound
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #008080"></div> Marine Geomorphic Features
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #9C27B0"></div> Mooring Areas
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #795548"></div> Marine Infrastructure
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #673AB7"></div> Potential Cleaning Zones
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #000"></div> Navigation Aids
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #FF5500"></div> Marine Traffic (AIS)
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #00AAFF"></div> Weather & Wind
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #FF0000"></div> Navigational Warnings
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #3d83b3"></div> Bathymetry (Depth Contours)
      </div>
    </div>
    <div id="serverStatus">
      <span class="status-dot status-connecting"></span>
      <span id="statusText">Connecting to server...</span>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js" crossorigin=""></script>
  <script>
    // Configuration
    const API_CONFIG = {
      local: 'http://localhost:3000',
      production: 'https://shipcleaninggis-server.onrender.com'
    };

    const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    const apiBaseUrl = isLocalhost ? API_CONFIG.local : API_CONFIG.production;

    const STUDY_AREA = {
      type: 'Feature',
      properties: { type: 'Study Area', description: 'Coastal region from Lancelin to Mandurah including Rottnest Island' },
      geometry: {
        type: 'Polygon',
        coordinates: [[
          [115.2, -32.60],
          [116.0, -32.60],
          [116.0, -30.90],
          [115.2, -30.90],
          [115.2, -32.60]
        ]]
      }
    };

    setTimeout(() => {
      map.invalidateSize();
      map.fitBounds([[-32.60, 115.2], [-30.90, 116.0]]);
    }, 200);

    const NAVIGATION_AIDS = {
      type: 'FeatureCollection',
      features: [
        { type: 'Feature', properties: { name: 'Fremantle Lighthouse', type: 'lighthouse', characteristics: 'Fl W 10s 30m 19M', description: 'Main lighthouse at Fremantle Port entrance' }, geometry: { type: 'Point', coordinates: [115.745, -32.045] } },
        // [Additional navigation aids data truncated for brevity]
      ]
    };

    const ENHANCED_COASTLINE = {
      type: 'FeatureCollection',
      features: [
        {
          type: 'Feature',
          properties: { name: 'Perth Coastline', type: 'land' },
          geometry: {
            type: 'Polygon',
            coordinates: [[
              [115.750, -32.150], [115.775, -32.150], [115.765, -32.140], [115.762, -32.135], [115.760, -32.130],
              [115.758, -32.125], [115.756, -32.120], [115.754, -32.115], [115.752, -32.111], [115.750, -32.107],
              [115.749, -32.103], [115.748, -32.100], [115.747, -32.095], [115.745, -32.090], [115.743, -32.085],
              [115.742, -32.080], [115.740, -32.075], [115.739, -32.070], [115.738, -32.065], [115.737, -32.060],
              [115.737, -32.058], [115.737, -32.055], [115.737, -32.052], [115.738, -32.050], [115.738, -32.048],
              [115.739, -32.046], [115.738, -32.044], [115.736, -32.042], [115.730, -32.040], [115.729, -32.038],
              [115.729, -32.036], [115.728, -32.034], [115.728, -32.032], [115.728, -32.030], [115.729, -32.028],
              [115.729, -32.026], [115.730, -32.024], [115.730, -32.022], [115.731, -32.020], [115.732, -32.018],
              [115.732, -32.016], [115.733, -32.014], [115.734, -32.012], [115.735, -32.010], [115.736, -32.008],
              [115.737, -32.006], [115.738, -32.004], [115.739, -32.002], [115.740, -32.000], [115.741, -31.998],
              [115.742, -31.996], [115.743, -31.994], [115.744, -31.992], [115.745, -31.990], [115.746, -31.988],
              [115.747, -31.986], [115.748, -31.984], [115.749, -31.982], [115.750, -31.980], [115.751, -31.978],
              [115.752, -31.976], [115.753, -31.974], [115.754, -31.972], [115.755, -31.970], [115.757, -31.968],
              [115.760, -31.966], [115.764, -31.964], [115.768, -31.963], [115.772, -31.962], [115.775, -31.961],
              [115.779, -31.959], [115.782, -31.957], [115.785, -31.955], [115.750, -32.150]
            ]]
          }
        },
        {
          type: 'Feature',
          properties: { name: 'Northern Land Area', type: 'land' },
          geometry: {
            type: 'Polygon',
            coordinates: [[
              [115.756, -31.970], [115.770, -31.970], [115.770, -31.990], [115.760, -32.000], [115.756, -31.990], [115.756, -31.970]
            ]]
          }
        }
      ]
    };

    let map;
    let currentMarker = null;
    let tempClickLocation = null;
    let serverOnline = false;
    let loadingStartTime;
    let cachedData = {};
    let totalLoadItems = 9;
    let loadedItems = 0;
    let progressInterval;
    let serverWakeupAttempts = 0;
    const MAX_WAKEUP_ATTEMPTS = 3;
    let zoneCalculationPolling = null;
    let zoneCalculationStartTime = null;
    let zoneCalculationRetries = 0;
    const MAX_ZONE_CALCULATION_RETRIES = 3;

    const activeLayerKeys = [
      'portAuthorities', 'marineParks', 'fishHabitat', 'cockburnSound', 'mooringAreas',
      'marineInfrastructure', 'marineGeomorphic', 'marineMultibeam', 'recommendedZones'
    ];

    const govLayers = {
      portAuthorities: { url: `/api/portAuthorities`, style: { color: '#FF4081', weight: 2, opacity: 0.8, fillOpacity: 0.2 }, layer: null },
      marineParks: { url: `/api/marineParks`, style: { color: '#4CAF50', weight: 2, opacity: 0.8, fillOpacity: 0.2 }, layer: null },
      fishHabitat: { url: `/api/fishHabitat`, style: { color: '#FF9800', weight: 2, opacity: 0.8, fillOpacity: 0.2 }, layer: null },
      cockburnSound: { url: `/api/cockburnSound`, style: { color: '#2196F3', weight: 2, opacity: 0.8, fillOpacity: 0.2 }, layer: null },
      mooringAreas: { url: `/api/mooringAreas`, style: { color: '#9C27B0', weight: 2, opacity: 0.8, fillOpacity: 0.2 }, layer: null },
      marineInfrastructure: { url: `/api/marineInfrastructure`, style: { color: '#795548', weight: 2, opacity: 0.8, fillOpacity: 0.2 }, layer: null },
      marineGeomorphic: { url: `/api/marineGeomorphic`, style: { color: '#008080', weight: 2, opacity: 0.8, fillOpacity: 0.15 }, layer: null },
      marineMultibeam: { url: `/api/marineMultibeam`, style: { color: '#006400', weight: 2, opacity: 0.8, fillOpacity: 0.2 }, layer: null },
      recommendedZones: { url: `/api/recommendedZones`, style: { color: '#673AB7', weight: 2, opacity: 0.8, fillOpacity: 0.2 }, layer: null }
    };

    const layerColors = {
      portAuthorities: '#FF4081', marineParks: '#4CAF50', fishHabitat: '#FF9800',
      cockburnSound: '#2196F3', mooringAreas: '#9C27B0', marineInfrastructure: '#795548',
      marineGeomorphic: '#008080', marineMultibeam: '#006400', recommendedZones: '#673AB7'
    };

    async function initMap() {
      try {
        loadingStartTime = Date.now();
        progressInterval = setInterval(() => {
          const elapsedSeconds = Math.floor((Date.now() - loadingStartTime) / 1000);
          document.getElementById('loadingSubMessage').textContent =
            `This map is running on a free server which may take up to 60 seconds to wake up. (${elapsedSeconds}s elapsed)`;
        }, 1000);

        const serverAvailable = await checkServerStatus();
        if (!serverAvailable) await wakeupServer();

        map = L.map('map').setView([-32.05, 115.73], 12);
        const baseLayers = {
          "ESRI Ocean Base": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Ocean_Basemap/MapServer/tile/{z}/{y}/{x}', {
            maxZoom: 19,
            attribution: 'Tiles © Esri — Sources: GEBCO, NOAA, CHS, OSU, UNH, CSUMB, National Geographic, DeLorme, NAVTEQ, and Esri'
          }),
          "OpenStreetMap": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '© OpenStreetMap contributors'
          })
        };
        baseLayers["ESRI Ocean Base"].addTo(map);

        const layerControl = L.control.layers(baseLayers, null, { position: 'topleft', collapsed: false }).addTo(map);

        map.on('click', e => {
          tempClickLocation = e.latlng;
          document.getElementById('confirmationModal').style.display = 'block';
        });

        document.getElementById('confirmYes').addEventListener('click', () => {
          if (tempClickLocation) {
            document.getElementById('confirmationModal').style.display = 'none';
            analyzeLocation(tempClickLocation.lat, tempClickLocation.lng);
          }
        });

        document.getElementById('confirmNo').addEventListener('click', () => {
          document.getElementById('confirmationModal').style.display = 'none';
          tempClickLocation = null;
          if (currentMarker) {
            map.removeLayer(currentMarker);
            currentMarker = null;
          }
        });

        document.getElementById('analysisClose').addEventListener('click', () => {
          document.getElementById('analysisContainer').style.display = 'none';
          if (currentMarker) {
            map.removeLayer(currentMarker);
            currentMarker = null;
          }
        });

        const loadPromises = activeLayerKeys
          .filter(key => key !== 'recommendedZones')
          .map(key => {
            updateLayerLoadingState(key, true);
            updateLoadingMessage(`Loading ${key.replace(/([A-Z])/g, ' $1').toLowerCase()}...`);
            return fetchLayerData(govLayers[key].url, key)
              .then(geojson => {
                try {
                  govLayers[key].layer = L.geoJSON(geojson, {
                    style: govLayers[key].style,
                    onEachFeature: (feature, layer) => {
                      if (feature.properties) {
                        const popupContent = Object.entries(feature.properties)
                          .map(([prop, value]) => `<strong>${prop}:</strong> ${value}`).join('<br>');
                        layer.bindPopup(popupContent);
                      }
                    }
                  }).addTo(map);

                  govLayers[key].layer.on('click', e => {
                    L.DomEvent.stopPropagation(e);
                    tempClickLocation = e.latlng;
                    document.getElementById('confirmationModal').style.display = 'block';
                  });

                  const checkbox = document.getElementById(key + 'Checkbox');
                  if (checkbox) {
                    checkbox.addEventListener('change', e => {
                      e.target.checked ? map.addLayer(govLayers[key].layer) : map.removeLayer(govLayers[key].layer);
                    });
                  }
                } catch (error) {
                  console.error(`Error creating layer for ${key}:`, error);
                  throw error;
                }
                updateLayerLoadingState(key, false);
              })
              .catch(err => {
                console.error(`Error loading ${key}:`, err);
                updateLayerLoadingState(key, false, err);
                showError(`Failed to load ${key}. Click retry to try again.`);
                const checkbox = document.getElementById(key + 'Checkbox');
                if (checkbox) {
                  checkbox.addEventListener('change', e => {
                    if (e.target.checked && !govLayers[key].layer) {
                      showError(`${key} data is not available. Please click retry to load.`);
                      e.target.checked = false;
                    }
                  });
                }
              });
          });

        loadPromises.push(loadRecommendedZones());
        await Promise.allSettled(loadPromises);

        const nauticalOverlays = {};

        try {
          const navigationAidsLayer = createNavigationAidsLayer();
          if (navigationAidsLayer) {
            nauticalOverlays['Navigation Aids'] = navigationAidsLayer;
            layerControl.addOverlay(navigationAidsLayer, 'Navigation Aids');
            const checkbox = document.getElementById('navigationAidsCheckbox');
            if (checkbox && checkbox.checked) navigationAidsLayer.addTo(map);
            if (checkbox) checkbox.addEventListener('change', e => e.target.checked ? map.addLayer(navigationAidsLayer) : map.removeLayer(navigationAidsLayer));
          }
        } catch (error) {
          console.error('Error setting up navigation aids layer:', error);
        }

        try {
          const marineTrafficLayer = createMarineTrafficLayer();
          if (marineTrafficLayer) {
            nauticalOverlays['Marine Traffic'] = marineTrafficLayer;
            layerControl.addOverlay(marineTrafficLayer, 'Marine Traffic (AIS)');
            const checkbox = document.getElementById('marineTrafficCheckbox');
            if (checkbox) {
              if (checkbox.checked) marineTrafficLayer.addTo(map);
              checkbox.addEventListener('change', e => e.target.checked ? map.addLayer(marineTrafficLayer) : map.removeLayer(marineTrafficLayer));
            }
          }
        } catch (error) {
          console.error('Error setting up marine traffic layer:', error);
        }

        try {
          const weatherLayer = createWeatherLayer();
          if (weatherLayer) {
            nauticalOverlays['Weather'] = weatherLayer;
            layerControl.addOverlay(weatherLayer, 'Weather & Wind');
            const checkbox = document.getElementById('weatherCheckbox');
            if (checkbox) {
              if (checkbox.checked) weatherLayer.addTo(map);
              checkbox.addEventListener('change', e => e.target.checked ? map.addLayer(weatherLayer) : map.removeLayer(weatherLayer));
            }
          }
        } catch (error) {
          console.error('Error setting up weather layer:', error);
        }

        try {
          const navWarningsLayer = createNavigationalWarningsLayer();
          if (navWarningsLayer) {
            nauticalOverlays['Navigational Warnings'] = navWarningsLayer;
            layerControl.addOverlay(navWarningsLayer, 'Navigational Warnings');
            const checkbox = document.getElementById('navigationalWarningsCheckbox');
            if (checkbox) {
              if (checkbox.checked) navWarningsLayer.addTo(map);
              checkbox.addEventListener('change', e => e.target.checked ? map.addLayer(navWarningsLayer) : map.removeLayer(navWarningsLayer));
            }
          }
        } catch (error) {
          console.error('Error setting up navigational warnings layer:', error);
        }

        try {
          const bathymetryLayer = await createBathymetryLayer();
          if (bathymetryLayer) {
            nauticalOverlays['Bathymetry'] = bathymetryLayer;
            layerControl.addOverlay(bathymetryLayer, 'Bathymetry (Depth Contours)');
            const checkbox = document.getElementById('bathymetryCheckbox');
            if (checkbox && checkbox.checked) bathymetryLayer.addTo(map);
            if (checkbox) checkbox.addEventListener('change', e => e.target.checked ? map.addLayer(bathymetryLayer) : map.removeLayer(bathymetryLayer));
          }
        } catch (error) {
          console.error('Error setting up bathymetry layer:', error);
        }

        try {
          if (govLayers.marineMultibeam.layer) {
            layerControl.addOverlay(govLayers.marineMultibeam.layer, 'High-Resolution Bathymetry');
            const checkbox = document.getElementById('marineMultibeamCheckbox');
            if (checkbox) checkbox.addEventListener('change', e => e.target.checked ? map.addLayer(govLayers.marineMultibeam.layer) : map.removeLayer(govLayers.marineMultibeam.layer));
            updateLayerLoadingState('marineMultibeam', false);
          }
        } catch (error) {
          console.error('Error setting up multibeam bathymetry layer:', error);
          updateLayerLoadingState('marineMultibeam', false);
        }

        try {
          addCompassRose();
        } catch (error) {
          console.error('Error adding compass rose:', error);
        }

        setTimeout(() => {
          map.invalidateSize();
          map.fitBounds([[-32.15, 115.65], [-31.95, 115.85]]);
        }, 200);
      } catch (error) {
        console.error('Map initialization error:', error);
        showError(`Failed to initialize map: ${error.message}`);
      } finally {
        if (progressInterval) clearInterval(progressInterval);
        setTimeout(() => document.getElementById('loadingOverlay').style.display = 'none', 1000);
        setInterval(checkServerStatus, 60000);
      }
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initMap);
    } else {
      initMap();
    }

    document.getElementById('forceClearCalculation').addEventListener('click', async function () {
      document.getElementById('loadingOverlay').style.display = 'flex';
      document.getElementById('loadingMessage').textContent = 'Clearing cache and recalculating...';
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.includes('gisapp_')) {
          console.log('Removing cached item:', key);
          localStorage.removeItem(key);
        }
      }
      cachedData = {};
      if (serverOnline) {
        try {
          const response = await fetch(`${apiBaseUrl}/api/clearCache`);
          const data = await response.json();
          console.log('Server cache cleared:', data);
        } catch (error) {
          console.error('Failed to clear server cache:', error);
        }
      }
      window.location.reload();
    });

    function createNavigationAidsLayer() {
      try {
        updateLayerLoadingState('navigationAids', true);
        const layer = L.layerGroup();
        NAVIGATION_AIDS.features.forEach(feature => {
          const { name, type, characteristics, description } = feature.properties;
          const [lng, lat] = feature.geometry.coordinates;
          let iconHtml, className;
          switch (type) {
            case 'lighthouse': iconHtml = '🗼'; className = 'lighthouse'; break;
            case 'buoy-port': iconHtml = '⚫'; className = 'buoy-port'; break;
            case 'buoy-starboard': iconHtml = '⚫'; className = 'buoy-starboard'; break;
            case 'anchorage': iconHtml = '⚓'; className = 'anchorage'; break;
            case 'danger': iconHtml = '⚠️'; className = 'danger'; break;
            default: iconHtml = '🚩'; className = 'navigation-aids';
          }
          const icon = L.divIcon({ html: `<div class="${className}">${iconHtml}</div>`, className: 'navigation-aids', iconSize: [24, 24], iconAnchor: [12, 12] });
          const marker = L.marker([lat, lng], { icon }).bindPopup(
            `<strong>${name}</strong><br>Type: ${type.replace('-', ' ')}<br>${characteristics ? `Characteristics: ${characteristics}<br>` : ''}${description}`
          );
          layer.addLayer(marker);
        });
        updateLayerLoadingState('navigationAids', false);
        return layer;
      } catch (error) {
        console.error('Error creating navigation aids layer:', error);
        updateLayerLoadingState('navigationAids', false);
        const fallback = L.layerGroup();
        const icon = L.divIcon({ html: `<div class="navigation-aids">🚩</div>`, className: 'navigation-aids', iconSize: [24, 24], iconAnchor: [12, 12] });
        fallback.addLayer(L.marker([-32.045, 115.745], { icon }).bindPopup("Fremantle Lighthouse (Fallback)"));
        return fallback;
      }
    }

    function createMarineTrafficLayer() {
      const layer = L.layerGroup();
      const vessels = [
        { pos: [-32.025, 115.710], name: 'Cargo Vessel', type: 'cargo', heading: 45, speed: 12, icon: '🚢' },
        { pos: [-32.040, 115.690], name: 'Oil Tanker', type: 'tanker', heading: 180, speed: 8, icon: '🛳️' },
        { pos: [-32.055, 115.705], name: 'Passenger Ferry', type: 'passenger', heading: 270, speed: 15, icon: '🚢' },
        { pos: [-32.035, 115.725], name: 'Fishing Vessel', type: 'fishing', heading: 90, speed: 5, icon: '🚣' },
        { pos: [-32.015, 115.745], name: 'Navy Vessel', type: 'military', heading: 135, speed: 18, icon: '⚓' }
      ];
      vessels.forEach(vessel => {
        const marker = L.marker(vessel.pos, {
          icon: L.divIcon({ html: `<div style="font-size: 20px; transform: rotate(${vessel.heading}deg);">${vessel.icon}</div>`, className: 'vessel-icon', iconSize: [30, 30], iconAnchor: [15, 15] })
        }).bindPopup(`<b>${vessel.name}</b><br>Type: ${vessel.type}<br>Heading: ${vessel.heading}°<br>Speed: ${vessel.speed} knots`);
        layer.addLayer(marker);
        const trackLine = L.polyline([
          vessel.pos,
          [vessel.pos[0] - Math.sin(vessel.heading * Math.PI / 180) * 0.01, vessel.pos[1] - Math.cos(vessel.heading * Math.PI / 180) * 0.01]
        ], { color: '#FF5500', weight: 2, opacity: 0.7, dashArray: '5, 5' });
        layer.addLayer(trackLine);
      });
      return layer;
    }

    function createWeatherLayer() {
      const layer = L.layerGroup();
      const stations = [
        { pos: [-32.030, 115.730], temp: 21, wind_speed: 15, wind_dir: 'NW', pressure: 1013 },
        { pos: [-32.060, 115.700], temp: 20, wind_speed: 12, wind_dir: 'W', pressure: 1012 },
        { pos: [-32.010, 115.760], temp: 22, wind_speed: 8, wind_dir: 'SW', pressure: 1014 }
      ];
      stations.forEach(station => {
        const marker = L.marker(station.pos, {
          icon: L.divIcon({ html: `<div style="font-size: 24px; color: #00AAFF;">🌤️</div>`, className: 'weather-icon', iconSize: [30, 30], iconAnchor: [15, 15] })
        }).bindPopup(`<b>Weather Station</b><br>Temperature: ${station.temp}°C<br>Wind: ${station.wind_speed} knots ${station.wind_dir}<br>Pressure: ${station.pressure} hPa`);
        layer.addLayer(marker);
        const dirMap = { 'N': 0, 'NE': 45, 'E': 90, 'SE': 135, 'S': 180, 'SW': 225, 'W': 270, 'NW': 315 };
        const dir = dirMap[station.wind_dir] || 0;
        const arrow = L.marker(station.pos, {
          icon: L.divIcon({ html: `<div style="font-size: 20px; transform: rotate(${dir}deg);">➡️</div>`, className: 'wind-direction', iconSize: [20, 20], iconAnchor: [10, 30] })
        });
        layer.addLayer(arrow);
      });
      return layer;
    }

    function createNavigationalWarningsLayer() {
      const layer = L.layerGroup();
      const warnings = [
        { pos: [-32.040, 115.725], title: 'Navigation Hazard', details: 'Submerged object reported in this area. Exercise caution.', type: 'hazard', polygon: [[-32.035, 115.720], [-32.030, 115.730], [-32.045, 115.735], [-32.050, 115.725], [-32.035, 115.720]] },
        { pos: [-32.060, 115.760], title: 'Restricted Area', details: 'Naval exercise zone active from June 1-5. All vessels prohibited.', type: 'restricted', polygon: [[-32.055, 115.755], [-32.050, 115.765], [-32.065, 115.770], [-32.070, 115.760], [-32.055, 115.755]] },
        { pos: [-32.025, 115.695], title: 'Strong Currents', details: 'Strong tidal currents reported in this area. Small vessels use caution.', type: 'current', radius: 0.005 }
      ];
      warnings.forEach(warning => {
        const marker = L.marker(warning.pos, {
          icon: L.divIcon({ html: `<div style="font-size: 24px; color: #FF0000;">⚠️</div>`, className: 'warning-icon', iconSize: [30, 30], iconAnchor: [15, 15] })
        }).bindPopup(`<b>${warning.title}</b><br>${warning.details}`);
        layer.addLayer(marker);
        if (warning.polygon) {
          const polygon = L.polygon(warning.polygon, { color: '#FF0000', weight: 2, opacity: 0.6, fillColor: '#FF0000', fillOpacity: 0.1, dashArray: '5, 5' }).bindPopup(`<b>${warning.title}</b><br>${warning.details}`);
          layer.addLayer(polygon);
        } else if (warning.radius) {
          const circle = L.circle(warning.pos, { radius: warning.radius * 111319.9, color: '#FF0000', weight: 2, opacity: 0.6, fillColor: '#FF0000', fillOpacity: 0.1, dashArray: '5, 5' }).bindPopup(`<b>${warning.title}</b><br>${warning.details}`);
          layer.addLayer(circle);
        }
      });
      return layer;
    }

    async function createBathymetryLayer() {
      const layer = L.layerGroup();
      updateLayerLoadingState('bathymetry', true);
      updateLoadingMessage('Loading bathymetry data...');
      const getDepthColor = depth => {
        if (depth <= 5) return '#a5ddff';
        if (depth <= 10) return '#77c3ec';
        if (depth <= 15) return '#5ba3d0';
        if (depth <= 20) return '#3d83b3';
        if (depth <= 30) return '#2064a0';
        if (depth <= 50) return '#1a4989';
        if (depth <= 100) return '#0f2e62';
        return '#071d42';
      };
      const getDepthClass = depth => {
        if (depth <= 5) return 'depth-contour-5';
        if (depth <= 10) return 'depth-contour-10';
        if (depth <= 15) return 'depth-contour-15';
        if (depth <= 20) return 'depth-contour-20';
        if (depth <= 30) return 'depth-contour-30';
        if (depth <= 50) return 'depth-contour-50';
        return 'depth-contour-100';
      };
      try {
        const cachedBathymetry = getFromLocalStorage('bathymetry');
        if (cachedBathymetry) {
          console.log('Using cached bathymetry data');
          displayBathymetry(cachedBathymetry);
          updateLayerLoadingState('bathymetry', false);
          return layer;
        }
        if (serverOnline) {
          try {
            const response = await fetch(`${apiBaseUrl}/api/bathymetry`);
            if (response.ok) {
              const data = await response.json();
              if (data && data.features && data.features.length > 0) {
                saveToLocalStorage('bathymetry', data);
                displayBathymetry(data);
                updateLayerLoadingState('bathymetry', false);
                return layer;
              }
            }
          } catch (error) {
            console.warn('Failed to fetch bathymetry from server:', error);
          }
        }
      } catch (error) {
        console.error('Error creating bathymetry layer:', error);
      }
      const fallbackBathymetry = {
        type: 'FeatureCollection',
        features: [
          { type: 'Feature', properties: { depth: 5, name: '5m Depth Contour' }, geometry: { type: 'LineString', coordinates: [[115.735, -32.045], [115.739, -32.048], [115.742, -32.052], [115.745, -32.056], [115.748, -32.060], [115.745, -32.065], [115.740, -32.070], [115.735, -32.075]] } },
          { type: 'Feature', properties: { depth: 10, name: '10m Depth Contour' }, geometry: { type: 'LineString', coordinates: [[115.725, -32.040], [115.729, -32.043], [115.732, -32.047], [115.735, -32.051], [115.738, -32.055], [115.735, -32.060], [115.730, -32.065], [115.725, -32.070]] } },
          { type: 'Feature', properties: { depth: 15, name: '15m Depth Contour' }, geometry: { type: 'LineString', coordinates: [[115.715, -32.035], [115.719, -32.038], [115.722, -32.042], [115.725, -32.046], [115.728, -32.050], [115.725, -32.055], [115.720, -32.060], [115.715, -32.065]] } },
          { type: 'Feature', properties: { depth: 20, name: '20m Depth Contour' }, geometry: { type: 'LineString', coordinates: [[115.705, -32.030], [115.709, -32.033], [115.712, -32.037], [115.715, -32.041], [115.718, -32.045], [115.715, -32.050], [115.710, -32.055], [115.705, -32.060]] } }
        ]
      };
      saveToLocalStorage('bathymetry', fallbackBathymetry);
      displayBathymetry(fallbackBathymetry);
      updateLayerLoadingState('bathymetry', false);
      return layer;

      function displayBathymetry(data) {
        if (!data || !data.features || !data.features.length) {
          console.warn('Invalid bathymetry data:', data);
          return;
        }
        data.features.forEach(feature => {
          if (!feature.geometry) return;
          const depth = feature.properties.depth || 0;
          const name = feature.properties.name || `${depth}m depth`;
          const color = getDepthColor(depth);
          const depthClass = getDepthClass(depth);
          if (feature.geometry.type === 'LineString') {
            const points = feature.geometry.coordinates.map(coord => [coord[1], coord[0]]);
            const polyline = L.polyline(points, { color: color, weight: 2.5, opacity: 0.8, smoothFactor: 1, className: depthClass }).bindTooltip(`${name} (${depth}m)`, { sticky: true });
            layer.addLayer(polyline);
            if (points.length > 3) {
              const midIndex = Math.floor(points.length / 2);
              const label = L.marker(points[midIndex], {
                icon: L.divIcon({ html: `<div class="${depthClass}">${depth}m</div>`, className: 'depth-label', iconSize: [30, 14], iconAnchor: [15, 7] })
              });
              layer.addLayer(label);
            }
          } else if (feature.geometry.type === 'Point') {
            const point = [feature.geometry.coordinates[1], feature.geometry.coordinates[0]];
            const marker = L.marker(point, {
              icon: L.divIcon({ html: `<div class="${depthClass}">${depth}m</div>`, className: 'depth-label', iconSize: [36, 18], iconAnchor: [18, 9] })
            }).bindTooltip(`${name} - Depth: ${depth}m`, { sticky: true });
            layer.addLayer(marker);
          }
        });
      }
    }

    function addCompassRose() {
      const compassRose = L.control({ position: 'bottomleft' });
      compassRose.onAdd = function () {
        const div = L.DomUtil.create('div', 'compass-rose');
        div.innerHTML = `
          <svg width="100" height="100" viewBox="0 0 100 100">
            <circle cx="50" cy="50" r="45" fill="white" fill-opacity="0.7" stroke="#333" stroke-width="1" />
            <path d="M50,5 L55,45 L50,50 L45,45 Z" fill="#D32F2F" stroke="#333" stroke-width="0.5" />
            <path d="M50,95 L55,55 L50,50 L45,55 Z" fill="#333" stroke="#333" stroke-width="0.5" />
            <path d="M5,50 L45,45 L50,50 L45,55 Z" fill="#333" stroke="#333" stroke-width="0.5" />
            <path d="M95,50 L55,45 L50,50 L55,55 Z" fill="#333" stroke="#333" stroke-width="0.5" />
            <text x="50" y="20" text-anchor="middle" font-size="12" font-weight="bold">N</text>
            <text x="50" y="85" text-anchor="middle" font-size="12" font-weight="bold">S</text>
            <text x="85" y="52" text-anchor="middle" font-size="12" font-weight="bold">E</text>
            <text x="15" y="52" text-anchor="middle" font-size="12" font-weight="bold">W</text>
          </svg>
        `;
        return div;
      };
      compassRose.addTo(map);
    }

    function updateRecommendedZonesLayer(geojson) {
      try {
        if (govLayers.recommendedZones.layer) map.removeLayer(govLayers.recommendedZones.layer);
        if (!geojson || !geojson.features || !geojson.features.length) {
          console.error('Invalid recommended zones data:', geojson);
          showError('Invalid recommended zones data received');
          updateLayerLoadingState('recommendedZones', false);
          return false;
        }
        govLayers.recommendedZones.layer = L.geoJSON(geojson, {
          style: govLayers.recommendedZones.style,
          onEachFeature: (feature, layer) => {
            if (feature.properties) {
              const popupContent = Object.entries(feature.properties)
                .map(([prop, value]) => `<strong>${prop}:</strong> ${value}`).join('<br>');
              layer.bindPopup(popupContent);
            }
          }
        }).addTo(map);
        govLayers.recommendedZones.layer.on('click', e => {
          L.DomEvent.stopPropagation(e);
          tempClickLocation = e.latlng;
          document.getElementById('confirmationModal').style.display = 'block';
        });
        const checkbox = document.getElementById('recommendedZonesCheckbox');
        if (checkbox) {
          checkbox.checked = true;
          checkbox.addEventListener('change', e => {
            e.target.checked ? map.addLayer(govLayers.recommendedZones.layer) : map.removeLayer(govLayers.recommendedZones.layer);
          });
        }
        updateLayerLoadingState('recommendedZones', false);
        return true;
      } catch (error) {
        console.error('Error updating recommendedZones layer:', error);
        updateLayerLoadingState('recommendedZones', false);
        showError('Failed to update recommended zones: ' + error.message);
        return false;
      }
    }

    async function loadRecommendedZones() {
      updateLayerLoadingState('recommendedZones', true);
      updateLoadingMessage('Loading potential cleaning zones...');
      zoneCalculationRetries = 0;
      clearInterval(zoneCalculationPolling);
      if (cachedData.recommendedZones) {
        console.log('Using cached recommended zones');
        updateRecommendedZonesLayer(cachedData.recommendedZones);
        return Promise.resolve();
      }
      const localData = getFromLocalStorage('recommendedZones');
      if (localData) {
        console.log('Using localStorage recommended zones');
        cachedData.recommendedZones = localData;
        updateRecommendedZonesLayer(localData);
        return Promise.resolve();
      }
      if (serverOnline) {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 30000);
          const response = await fetch(`${apiBaseUrl}/api/recommendedZones`, { signal: controller.signal });
          clearTimeout(timeoutId);
          if (response.status === 202) {
            const data = await response.json();
            console.log('Zone calculation in progress:', data);
            setupZoneCalculationPolling(data);
            return Promise.resolve();
          } else if (response.ok) {
            const data = await response.json();
            cachedData.recommendedZones = data;
            saveToLocalStorage('recommendedZones', data);
            updateRecommendedZonesLayer(data);
            return Promise.resolve();
          } else {
            throw new Error(`Server returned status ${response.status}`);
          }
        } catch (error) {
          console.warn('Server-side zone calculation failed:', error);
        }
      }
      try {
        console.log('Calculating recommended zones on client-side');
        await calculateClientSideZones();
        return Promise.resolve();
      } catch (error) {
        console.error('Client-side zone calculation failed:', error);
        updateLayerLoadingState('recommendedZones', false);
        showError('Failed to calculate recommended zones: ' + error.message);
        return Promise.resolve();
      }
    }

    function saveToLocalStorage(key, data) {
      try {
        const serialized = JSON.stringify(data);
        const sizeInKB = serialized.length / 1024;
        if (sizeInKB > 6000) {
          console.warn(`Data for ${key} too large for localStorage (${sizeInKB.toFixed(2)}KB)`);
          return false;
        }
        if (data.type === 'FeatureCollection' && Array.isArray(data.features)) {
          const simplified = {
            type: 'FeatureCollection',
            features: data.features.map(feature => {
              if (!feature.geometry) return feature;
              const properties = {};
              if (feature.properties) {
                ['name', 'NAME', 'Name', 'type', 'depth', 'description'].forEach(prop => {
                  if (feature.properties[prop] !== undefined) properties[prop] = feature.properties[prop];
                });
              }
              return { type: 'Feature', properties, geometry: feature.geometry };
            }).slice(0, 100)
          };
          localStorage.setItem(`gisapp_${key}`, JSON.stringify({ timestamp: Date.now(), data: simplified }));
        } else {
          localStorage.setItem(`gisapp_${key}`, JSON.stringify({ timestamp: Date.now(), data: data }));
        }
        return true;
      } catch (error) {
        console.warn('Failed to save to localStorage:', error);
        if (error.name === 'QuotaExceededError') {
          try {
            const keysToRemove = [];
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key.startsWith('gisapp_')) keysToRemove.push(key);
            }
            keysToRemove.sort((a, b) => {
              try {
                const itemA = JSON.parse(localStorage.getItem(a));
                const itemB = JSON.parse(localStorage.getItem(b));
                return (itemA.timestamp || 0) - (itemB.timestamp || 0);
              } catch (e) {
                return 0;
              }
            });
            const removeCount = Math.ceil(keysToRemove.length / 2);
            keysToRemove.slice(0, removeCount).forEach(k => localStorage.removeItem(k));
          } catch (e) {
            console.warn('Failed to clean localStorage:', e);
          }
        }
        return false;
      }
    }

    function getFromLocalStorage(key, maxAgeHours = 24) {
      try {
        const stored = localStorage.getItem(`gisapp_${key}`);
        if (!stored) return null;
        const parsed = JSON.parse(stored);
        const ageHours = (Date.now() - parsed.timestamp) / (1000 * 60 * 60);
        if (ageHours > maxAgeHours) {
          localStorage.removeItem(`gisapp_${key}`);
          return null;
        }
        return parsed.data;
      } catch (error) {
        console.warn('Failed to retrieve from localStorage:', error);
        return null;
      }
    }

    function showError(message, duration = 5000) {
      const toast = document.getElementById('errorToast');
      toast.textContent = message;
      toast.style.display = 'block';
      setTimeout(() => toast.style.display = 'none', duration);
    }

    function showSuccessMessage(message, duration = 3000) {
      const toast = document.getElementById('successToast');
      toast.textContent = message;
      toast.style.display = 'block';
      setTimeout(() => toast.style.display = 'none', duration);
    }

    function updateServerStatus(status, message) {
      const statusDot = document.querySelector('.status-dot');
      const statusText = document.getElementById('statusText');
      statusDot.classList.remove('status-connecting', 'status-online', 'status-offline', 'status-degraded');
      switch (status) {
        case 'connecting': statusDot.classList.add('status-connecting'); break;
        case 'online': statusDot.classList.add('status-online'); serverOnline = true; break;
        case 'offline': statusDot.classList.add('status-offline'); serverOnline = false; break;
        case 'degraded': statusDot.classList.add('status-degraded'); serverOnline = true; break;
      }
      statusText.textContent = message || status;
    }

    function updateLoadingProgress() {
      const progressFill = document.getElementById('progressFill');
      const progress = Math.min((loadedItems / totalLoadItems) * 100, 100);
      progressFill.style.width = `${progress}%`;
    }

    function updateLayerLoadingState(key, isLoading, error = null) {
      const control = document.querySelector(`#${key}Checkbox`);
      if (control) {
        const parent = control.closest('.layer-control');
        if (parent) {
          parent.classList.remove('layer-control-loading', 'layer-control-error');
          if (isLoading) {
            parent.classList.add('layer-control-loading');
          } else if (error) {
            parent.classList.add('layer-control-error');
            let errorMsg = parent.querySelector('.layer-error-message');
            if (!errorMsg) {
              errorMsg = document.createElement('div');
              errorMsg.className = 'layer-error-message';
              parent.appendChild(errorMsg);
            }
            errorMsg.textContent = 'Unable to load data';
            let retryBtn = parent.querySelector('.layer-retry-button');
            if (!retryBtn) {
              retryBtn = document.createElement('button');
              retryBtn.className = 'layer-retry-button';
              retryBtn.textContent = 'Retry';
              retryBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                retryLoadLayer(key);
              });
              parent.appendChild(retryBtn);
            }
          }
        }
      }
      if (!isLoading) {
        loadedItems++;
        updateLoadingProgress();
      }
    }

    async function retryLoadLayer(key) {
      if (!govLayers[key]) return;
      try {
        const layerControl = document.querySelector(`#${key}Checkbox`).closest('.layer-control');
        const errorMsg = layerControl.querySelector('.layer-error-message');
        if (errorMsg) errorMsg.remove();
        updateLayerLoadingState(key, true);
        delete cachedData[key];
        const data = await fetchLayerData(govLayers[key].url, key);
        if (govLayers[key].layer) map.removeLayer(govLayers[key].layer);
        govLayers[key].layer = L.geoJSON(data, {
          style: govLayers[key].style,
          onEachFeature: (feature, layer) => {
            if (feature.properties) {
              const popupContent = Object.entries(feature.properties)
                .map(([prop, value]) => `<strong>${prop}:</strong> ${value}`).join('<br>');
              layer.bindPopup(popupContent);
            }
          }
        }).addTo(map);
        govLayers[key].layer.on('click', e => {
          L.DomEvent.stopPropagation(e);
          tempClickLocation = e.latlng;
          document.getElementById('confirmationModal').style.display = 'block';
        });
        updateLayerLoadingState(key, false);
        const retryBtn = layerControl.querySelector('.layer-retry-button');
        if (retryBtn) retryBtn.remove();
      } catch (error) {
        console.error(`Error retrying layer ${key}:`, error);
        updateLayerLoadingState(key, false, error);
        showError(`Failed to load ${key} data. Please try again.`);
      }
    }

    function updateLoadingMessage(message, showProgress = true) {
      const loadingMsg = document.getElementById('loadingMessage');
      loadingMsg.textContent = message;
      if (showProgress) {
        const elapsedSeconds = Math.floor((Date.now() - loadingStartTime) / 1000);
        document.getElementById('loadingSubMessage').textContent =
          `This map is running on a free server which may take up to 60 seconds to wake up. (${elapsedSeconds}s elapsed)`;
      }
    }

    async function checkServerStatus() {
      try {
        updateServerStatus('connecting', 'Checking server status...');
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000);
        const response = await fetch(`${apiBaseUrl}/healthcheck`, { signal: controller.signal, headers: { 'Cache-Control': 'no-cache' } });
        clearTimeout(timeoutId);
        if (response.ok) {
          updateServerStatus('online', 'Server online');
          return true;
        } else {
          updateServerStatus('degraded', 'Server responding with errors');
          return false;
        }
      } catch (error) {
        console.warn('Server health check failed:', error);
        updateServerStatus('offline', 'Server unavailable - using offline mode');
        return false;
      }
    }

    async function wakeupServer() {
      if (serverWakeupAttempts >= MAX_WAKEUP_ATTEMPTS) {
        console.warn(`Max server wakeup attempts (${MAX_WAKEUP_ATTEMPTS}) reached, falling back to local data`);
        updateServerStatus('offline', 'Server unavailable - using offline mode');
        return false;
      }
      try {
        serverWakeupAttempts++;
        updateServerStatus('connecting', `Waking up server (attempt ${serverWakeupAttempts}/${MAX_WAKEUP_ATTEMPTS})...`);
        updateLoadingMessage(`Waking up server (attempt ${serverWakeupAttempts}/${MAX_WAKEUP_ATTEMPTS})...`);
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000);
        const response = await fetch(`${apiBaseUrl}/warmup`, { signal: controller.signal, headers: { 'Cache-Control': 'no-cache' } });
        clearTimeout(timeoutId);
        if (response.ok) {
          updateServerStatus('online', 'Server online and ready');
          return true;
        } else {
          throw new Error(`Server returned ${response.status}`);
        }
      } catch (error) {
        console.warn(`Server wakeup attempt ${serverWakeupAttempts} failed:`, error);
        updateServerStatus('connecting', 'Server still waking up...');
        const waitTime = Math.min(2000 * Math.pow(2, serverWakeupAttempts - 1), 15000);
        await new Promise(resolve => setTimeout(resolve, waitTime));
        if (serverWakeupAttempts < MAX_WAKEUP_ATTEMPTS) return wakeupServer();
        else {
          updateServerStatus('offline', 'Server unavailable - using offline mode');
          return false;
        }
      }
    }

    async function fetchLayerData(url, key) {
      try {
        if (cachedData[key]) {
          console.log(`Using memory-cached data for ${key}`);
          return cachedData[key];
        }
        const localData = getFromLocalStorage(key);
        if (localData) {
          console.log(`Using localStorage data for ${key}`);
          cachedData[key] = localData;
          return localData;
        }
        updateLoadingMessage(`Fetching ${key.replace(/([A-Z])/g, ' $1').toLowerCase()}...`);
        if (!serverOnline) throw new Error('Server is offline');
        const timeoutDuration = key === 'recommendedZones' ? 60000 : 30000;
        const fullUrl = url.startsWith('http') ? url : `${apiBaseUrl}${url}`;
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeoutDuration);
        console.log(`Fetching data from: ${fullUrl}`);
        const response = await fetch(fullUrl, { signal: controller.signal, headers: { 'Cache-Control': 'no-cache' } });
        clearTimeout(timeoutId);
        if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
        const data = await response.json();
        if (key === 'recommendedZones' && data.status === 'calculating') {
          console.log('Zone calculation in progress, setting up polling');
          setupZoneCalculationPolling(data);
          throw new Error('Zone calculation in progress');
        }
        cachedData[key] = data;
        saveToLocalStorage(key, data);
        return data;
      } catch (error) {
        console.error(`Error fetching ${key}:`, error);
        throw error;
      }
    }

    function formatTime(seconds) {
      const minutes = Math.floor(seconds / 60);
      const remainingSeconds = seconds % 60;
      return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
    }

    function setupZoneCalculationPolling(initialData) {
      const calculationStatus = document.getElementById('zoneCalculationStatus');
      const progressDisplay = document.getElementById('calculationProgress');
      const timeDisplay = document.getElementById('calculationTime');
      if (calculationStatus) {
        calculationStatus.style.display = 'block';
        document.getElementById('sidebar').scrollTo({ top: calculationStatus.offsetTop - 100, behavior: 'smooth' });
      }
      zoneCalculationStartTime = Date.now();
      const initialProgress = Math.max(5, initialData.progress || 0);
      if (progressDisplay) progressDisplay.textContent = `${initialProgress}%`;
      if (!document.getElementById('zoneProgressBar')) {
        const progressBarHTML = `
          <div id="zoneProgressBar" style="width: 100%; background-color: #f3f3f3; height: 8px; margin-top: 5px; border-radius: 4px; overflow: hidden;">
            <div id="zoneProgressFill" style="height: 100%; width: ${initialProgress}%; background-color: #673AB7; border-radius: 4px; transition: width 0.5s ease;"></div>
          </div>
        `;
        calculationStatus.insertAdjacentHTML('beforeend', progressBarHTML);
      } else {
        const progressFill = document.getElementById('zoneProgressFill');
        if (progressFill) progressFill.style.width = `${initialProgress}%`;
      }

      let pollAttempts = 0;
      const MAX_POLL_ATTEMPTS = 150; // 5 minutes at 2-second intervals

      clearInterval(zoneCalculationPolling);
      zoneCalculationPolling = setInterval(async () => {
        if (pollAttempts >= MAX_POLL_ATTEMPTS) {
          clearInterval(zoneCalculationPolling);
          console.warn('Max polling attempts reached for zone calculation');
          if (calculationStatus) {
            calculationStatus.innerHTML = `
              <div style="color: #e53935; margin-top: 10px;">
                Zone calculation taking longer than expected. Please try again later.
                <button id="retryZoneCalculation" class="retry-button">Retry</button>
              </div>
            `;
            document.getElementById('retryZoneCalculation')?.addEventListener('click', () => {
              calculationStatus.style.display = 'none';
              loadRecommendedZones();
            });
          }
          return;
        }
        pollAttempts++;

        try {
          const response = await fetch(`${apiBaseUrl}/api/zoneCalculationStatus`);
          if (response.ok) {
            const data = await response.json();
            const progressValue = Math.max(5, data.progress || 0);
            if (progressDisplay) progressDisplay.textContent = `${progressValue}%`;
            const progressFill = document.getElementById('zoneProgressFill');
            if (progressFill) progressFill.style.width = `${progressValue}%`;
            const elapsedSeconds = Math.floor((Date.now() - zoneCalculationStartTime) / 1000);
            if (timeDisplay) {
              timeDisplay.innerHTML = `
                Elapsed: ${formatTime(elapsedSeconds)}<br>
                ${data.estimatedTimeRemaining ? `Estimated: ${data.estimatedTimeRemaining}` : 'Calculating...'}
              `;
            }
            if (!data.inProgress && data.lastCompleted) {
              console.log('Zone calculation complete, fetching results');
              clearInterval(zoneCalculationPolling);
              if (progressDisplay) progressDisplay.textContent = `100%`;
              if (progressFill) progressFill.style.width = `100%`;
              if (timeDisplay) timeDisplay.textContent = `Completed in ${formatTime(elapsedSeconds)}`;
              setTimeout(async () => {
                try {
                  if (calculationStatus) calculationStatus.style.display = 'none';
                  const response = await fetch(`${apiBaseUrl}/api/recommendedZones`);
                  if (response.ok) {
                    const zonesData = await response.json();
                    cachedData.recommendedZones = zonesData;
                    saveToLocalStorage('recommendedZones', zonesData);
                    updateRecommendedZonesLayer(zonesData);
                    showSuccessMessage('Recommended zones calculated successfully!');
                  }
                } catch (error) {
                  console.error('Failed to fetch completed zones:', error);
                  showError('Could not load recommended zones. Please try again.');
                }
              }, 1500);
            }
            if (data.error) {
              console.warn('Zone calculation error:', data.error);
              clearInterval(zoneCalculationPolling);
              if (calculationStatus) {
                calculationStatus.innerHTML = `
                  <div style="color: #e53935; margin-top: 10px;">
                    Error calculating zones: ${data.error}
                    <button id="retryZoneCalculation" class="retry-button">Retry</button>
                  </div>
                `;
                document.getElementById('retryZoneCalculation')?.addEventListener('click', () => {
                  calculationStatus.style.display = 'none';
                  loadRecommendedZones();
                });
              }
              if (zoneCalculationRetries < MAX_ZONE_CALCULATION_RETRIES) {
                zoneCalculationRetries++;
                console.log(`Retrying zone calculation (attempt ${zoneCalculationRetries}/${MAX_ZONE_CALCULATION_RETRIES})`);
                loadRecommendedZones();
              }
            }
          }
        } catch (error) {
          console.warn('Error checking zone calculation status:', error);
        }
      }, 2000);
    }

    function createWaterMask(coastlineData) {
      try {
        let landUnion = coastlineData.features[0];
        for (let i = 1; i < coastlineData.features.length; i++) {
          landUnion = turf.union(landUnion, coastlineData.features[i]);
        }
        const bufferedLand = turf.buffer(landUnion, 0.02, { units: 'degrees' });
        return turf.difference(STUDY_AREA, bufferedLand);
      } catch (error) {
        return null;
      }
    }
    async function analyzeLocation(lat, lng) {
      try {
        document.getElementById('loadingMessage').textContent = 'Analyzing location...';
        document.getElementById('loadingSubMessage').textContent = 'Calculating proximities to constraints...';
        document.getElementById('loadingOverlay').style.display = 'flex';
        if (currentMarker) map.removeLayer(currentMarker);
        const markerHtml = `<div class="analysis-marker">?</div>`;
        const icon = L.divIcon({ html: markerHtml, className: '', iconSize: [30, 30], iconAnchor: [15, 15] });
        currentMarker = L.marker([lat, lng], { icon }).addTo(map);
        let analysisData;
        if (serverOnline) {
          try {
            const analyzeUrl = `${apiBaseUrl}/api/analyzeProximity`;
            console.log(`Sending analysis request to: ${analyzeUrl}`);
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000);
            const response = await fetch(analyzeUrl, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ lat, lng }),
              signal: controller.signal
            });
            clearTimeout(timeoutId);
            if (!response.ok) throw new Error(`Analysis request failed: ${response.statusText}`);
            analysisData = await response.json();
          } catch (error) {
            console.warn('Server-side analysis failed, using client-side:', error);
            analysisData = await performClientSideAnalysis(lat, lng);
          }
        } else {
          analysisData = await performClientSideAnalysis(lat, lng);
        }
        displayAnalysisResults(analysisData);
      } catch (error) {
        console.error('Analysis error:', error);
        showError(`Failed to analyze location: ${error.message}`);
      } finally {
        document.getElementById('loadingOverlay').style.display = 'none';
      }
    }

    async function performClientSideAnalysis(lat, lng) {
      try {
        updateLoadingMessage('Performing client-side analysis...');
        const point = turf.point([parseFloat(lng), parseFloat(lat)]);
        const analysisResults = {};
        const waterMask = createWaterMask(ENHANCED_COASTLINE);
        if (waterMask) {
          analysisResults.waterMask = { inWater: turf.booleanPointInPolygon(point, waterMask) };
        } else {
          analysisResults.waterMask = { error: 'Could not create water mask' };
        }
        analysisResults.nauticalReferences = {};
        NAVIGATION_AIDS.features.forEach(feature => {
          const featurePoint = turf.point(feature.geometry.coordinates);
          const distance = turf.distance(point, featurePoint);
          const bearing = turf.bearing(point, featurePoint);
          const normalizedBearing = (bearing + 360) % 360;
          const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW', 'N'];
          const bearingText = directions[Math.round(normalizedBearing / 22.5)];
          analysisResults.nauticalReferences[feature.properties.name] = {
            distance: distance.toFixed(2),
            bearing: bearing.toFixed(1),
            bearingText,
            type: feature.properties.type,
            description: feature.properties.description
          };
        });
        for (const key of activeLayerKeys) {
          if (key === 'recommendedZones') continue;
          if (govLayers[key].layer) {
            const layerGeoJSON = govLayers[key].layer.toGeoJSON();
            const isInside = layerGeoJSON.features.some(feature => {
              if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon')) {
                return turf.booleanPointInPolygon(point, feature);
              }
              return false;
            });
            let minDistance = Number.MAX_VALUE;
            let nearestFeature = null;
            layerGeoJSON.features.forEach(feature => {
              if (!feature.geometry) return;
              try {
                let distance;
                if (isInside && turf.booleanPointInPolygon(point, feature)) {
                  distance = 0;
                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
                  const line = turf.polygonToLine(feature);
                  const nearest = turf.nearestPointOnLine(line, point);
                  distance = turf.distance(point, nearest);
                } else if (feature.geometry.type === 'Point') {
                  const featurePoint = turf.point(feature.geometry.coordinates);
                  distance = turf.distance(point, featurePoint);
                } else {
                  const center = turf.centroid(feature);
                  distance = turf.distance(point, center);
                }
                if (distance < minDistance) {
                  minDistance = distance;
                  nearestFeature = feature;
                }
              } catch (e) {
                console.warn(`Error calculating distance for feature in ${key}:`, e);
              }
            });
            if (nearestFeature) {
              analysisResults[key] = {
                distance: minDistance.toFixed(2),
                insideFeature: isInside,
                featureName: nearestFeature.properties.NAME || nearestFeature.properties.Name || nearestFeature.properties.name || `${key.replace(/([A-Z])/g, ' $1').trim()} Feature`
              };
            } else {
              analysisResults[key] = { status: 'No features found' };
            }
          } else {
            analysisResults[key] = { status: 'Layer not loaded' };
          }
        }
        if (govLayers.recommendedZones.layer) {
          const zonesGeoJSON = govLayers.recommendedZones.layer.toGeoJSON();
          analysisResults.recommendedZone = {
            insideRecommendedZone: zonesGeoJSON.features.some(f => turf.booleanPointInPolygon(point, f))
          };
        } else if (cachedData.recommendedZones) {
          analysisResults.recommendedZone = {
            insideRecommendedZone: cachedData.recommendedZones.features.some(f => turf.booleanPointInPolygon(point, f))
          };
        } else {
          analysisResults.recommendedZone = { error: 'Recommended zones not available' };
        }
        return { coordinates: { lat, lng }, results: analysisResults };
      } catch (error) {
        console.error('Client-side analysis error:', error);
        return {
          coordinates: { lat, lng },
          results: { status: 'Analysis failed', error: error.message, recommendedZone: { error: 'Unable to perform analysis' } }
        };
      }
    }

    function displayAnalysisResults(data) {
      const container = document.getElementById('analysisContainer');
      const content = document.getElementById('analysisContent');
      content.innerHTML = '';
      const locationInfo = document.createElement('div');
      locationInfo.innerHTML = `<strong>Coordinates:</strong> ${data.coordinates.lat.toFixed(5)}, ${data.coordinates.lng.toFixed(5)}`;
      content.appendChild(locationInfo);
      if (!serverOnline) {
        const offlineNote = document.createElement('div');
        offlineNote.innerHTML = `<p style="color: #F44336;"><strong>Note:</strong> Using offline analysis mode. Results may not be as accurate as online mode.</p>`;
        content.appendChild(offlineNote);
      }
      if (document.getElementById('calculationProgress') && document.getElementById('zoneCalculationStatus').style.display !== 'none') {
        const calculationNote = document.createElement('div');
        calculationNote.innerHTML = `<p style="color: #FFA000;"><strong>Note:</strong> Recommended cleaning zone calculation is in progress. Results may update after calculation completes.</p>`;
        content.appendChild(calculationNote);
      }
      if (data.results.waterMask) {
        const waterDiv = document.createElement('div');
        waterDiv.className = 'analysis-item';
        if (data.results.waterMask.error) {
          waterDiv.innerHTML = `
        <div class="analysis-header">
          <div class="analysis-icon" style="background: #3d83b3"></div>
          <div class="analysis-title">Water Check</div>
        </div>
        <div class="analysis-detail">
          <p class="analysis-warning">Could not determine if location is in water.</p>
        </div>
      `;
        } else {
          const isInWater = data.results.waterMask.inWater === true;
          waterDiv.innerHTML = `
        <div class="analysis-header">
          <div class="analysis-icon" style="background: #3d83b3"></div>
          <div class="analysis-title">Water Check</div>
        </div>
        <div class="analysis-detail">
          <p class="${isInWater ? 'analysis-good' : 'analysis-warning'}">
            This location is ${isInWater ? '' : 'NOT '}in water.
          </p>
          ${!isInWater ? '<p>Ship cleaning must occur in water areas.</p>' : ''}
        </div>
      `;
        }
        content.appendChild(waterDiv);
      }
      if (data.results.nauticalReferences) {
        const nauticalDiv = document.createElement('div');
        nauticalDiv.className = 'analysis-item';
        let nauticalHTML = `
      <div class="analysis-header">
        <div class="analysis-icon" style="background: #0066CC"></div>
        <div class="analysis-title">Nautical References</div>
      </div>
      <div class="analysis-detail">
    `;
        Object.entries(data.results.nauticalReferences).forEach(([name, info]) => {
          nauticalHTML += `
        <p><strong>${name}</strong> (${info.type}): ${info.distance} km ${info.bearingText} (${info.bearing}°)<br><small>${info.description}</small></p>
      `;
        });
        nauticalHTML += `</div>`;
        nauticalDiv.innerHTML = nauticalHTML;
        content.appendChild(nauticalDiv);
      }
      if (data.results.recommendedZone) {
        const recommendationDiv = document.createElement('div');
        recommendationDiv.className = 'analysis-item';
        if (data.results.recommendedZone.error) {
          recommendationDiv.innerHTML = `
        <div class="analysis-header">
          <div class="analysis-icon" style="background: #673AB7"></div>
          <div class="analysis-title">Site Suitability</div>
        </div>
        <div class="analysis-detail">
          <p class="analysis-warning">Unable to determine if this location is in a recommended zone.</p>
        </div>
      `;
        } else {
          const isRecommended = data.results.recommendedZone.insideRecommendedZone;
          recommendationDiv.innerHTML = `
        <div class="analysis-header">
          <div class="analysis-icon" style="background: #673AB7"></div>
          <div class="analysis-title">Site Suitability</div>
        </div>
        <div class="analysis-detail">
          <p class="${isRecommended ? 'analysis-good' : 'analysis-warning'}">
            This location is ${isRecommended ? '' : 'NOT '}within a recommended cleaning zone.
          </p>
          ${data.results.recommendedZone.calculationInProgress ? '<p><small>Note: Zone calculation in progress - results may change.</small></p>' : ''}
        </div>
      `;
        }
        content.appendChild(recommendationDiv);
      }
      const sensitiveKeys = ['marineParks', 'fishHabitat', 'cockburnSound'];
      const sensitiveDiv = document.createElement('div');
      sensitiveDiv.className = 'analysis-item';
      let sensitiveHTML = `
    <div class="analysis-header">
      <div class="analysis-icon" style="background: #FF9800"></div>
      <div class="analysis-title">Sensitive Receptors</div>
    </div>
    <div class="analysis-detail">
  `;
      let foundAny = false;
      sensitiveKeys.forEach(k => {
        const result = data.results[k];
        if (result && !result.error && !result.status) {
          foundAny = true;
          const dist = parseFloat(result.distance);
          const inside = result.insideFeature;
          const nm = result.featureName;
          sensitiveHTML += `<p><strong>${nm}</strong>: ${dist} km away${inside ? ' (Inside)' : ''}</p>`;
        }
      });
      sensitiveHTML += `</div>`;
      if (foundAny) {
        sensitiveDiv.innerHTML = sensitiveHTML;
        content.appendChild(sensitiveDiv);
      }
      const constraints = Object.entries(data.results).filter(([key]) =>
        key !== 'recommendedZone' && key !== 'nauticalReferences' && key !== 'waterMask' && !sensitiveKeys.includes(key)
      );
      for (const [key, result] of constraints) {
        if (!activeLayerKeys.includes(key)) continue;
        const constraintDiv = document.createElement('div');
        constraintDiv.className = 'analysis-item';
        const constraintName = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
        if (result.error || result.status) {
          constraintDiv.innerHTML = `
        <div class="analysis-header">
          <div class="analysis-icon" style="background: ${layerColors[key] || '#666'}"></div>
          <div class="analysis-title">${constraintName}</div>
        </div>
        <div class="analysis-detail">
          <p>No proximity data available: ${result.error || result.status}</p>
        </div>
      `;
        } else {
          const isInside = result.insideFeature === true;
          const isClose = !isInside && result.distance && parseFloat(result.distance) < 1.0;
          const statusClass = isInside || isClose ? 'analysis-warning' : 'analysis-good';
          const statusText = isInside ? `Inside ${result.featureName}` :
            isClose ? `Close to ${result.featureName} (${result.distance} km)` :
              `${result.distance} km from nearest ${result.featureName}`;
          constraintDiv.innerHTML = `
        <div class="analysis-header">
          <div class="analysis-icon" style="background: ${layerColors[key] || '#666'}"></div>
          <div class="analysis-title">${constraintName}</div>
        </div>
        <div class="analysis-detail">
          <p class="${statusClass}">${statusText}</p>
        </div>
      `;
        }
        content.appendChild(constraintDiv);
      }
      container.style.display = 'block';
    }

    async function calculateClientSideZones() {
      try {
        const calculationStatus = document.getElementById('zoneCalculationStatus');
        const progressDisplay = document.getElementById('calculationProgress');
        const timeDisplay = document.getElementById('calculationTime');
        if (calculationStatus) {
          calculationStatus.style.display = 'block';
          calculationStatus.innerHTML = `<div>Calculating recommended zones: <span id="calculationProgress" class="calculation-progress">5%</span></div><div id="calculationTime" class="calculation-time">Loading constraints...</div><div id="zoneProgressBar" style="width: 100%; background-color: #f3f3f3; height: 8px; margin-top: 5px; border-radius: 4px; overflow: hidden;"><div id="zoneProgressFill" style="height: 100%; width: 5%; background-color: #673AB7; border-radius: 4px; transition: width 0.5s ease;"></div></div>`;
        }
        function updateProgress(percent, message) {
          const progress = Math.min(99, Math.max(5, Math.floor(percent)));
          if (progressDisplay) progressDisplay.textContent = `${progress}%`;
          const progressFill = document.getElementById('zoneProgressFill');
          if (progressFill) progressFill.style.width = `${progress}%`;
          if (timeDisplay && message) timeDisplay.textContent = message;
          return new Promise(resolve => setTimeout(resolve, 0));
        }
        function expandBBox(bbox, factor) {
          const centerX = (bbox[0] + bbox[2]) / 2;
          const centerY = (bbox[1] + bbox[3]) / 2;
          const width = (bbox[2] - bbox[0]) * factor;
          const height = (bbox[3] - bbox[1]) * factor;
          return [centerX - width / 2, centerY - height / 2, centerX + width / 2, centerY + height / 2];
        }
        const startTime = Date.now();
        await updateProgress(5, 'Creating water mask...');
        const waterMask = createWaterMask(ENHANCED_COASTLINE);
        if (!waterMask) throw new Error('Could not create water mask');
        await updateProgress(20, 'Processing constraints...');
        const constraints = [];
        for (const key of activeLayerKeys.filter(k => k !== 'recommendedZones')) {
          if (govLayers[key].layer) {
            const layerGeoJSON = govLayers[key].layer.toGeoJSON();
            if (layerGeoJSON.features && layerGeoJSON.features.length > 0) {
              const polygonFeatures = layerGeoJSON.features.filter(f => f.geometry && (f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'));
              constraints.push(...polygonFeatures);
            }
          }
        }
        await updateProgress(30, 'Creating grid of test points...');
        const originalBbox = turf.bbox(STUDY_AREA);
        const bbox = expandBBox(originalBbox, 1.2);
        const cellSize = 0.01;
        const grid = [];
        const totalPoints = Math.ceil((bbox[2] - bbox[0]) / cellSize) * Math.ceil((bbox[3] - bbox[1]) / cellSize);
        let processedPoints = 0;
        for (let x = bbox[0]; x <= bbox[2]; x += cellSize) {
          for (let y = bbox[1]; y <= bbox[3]; y += cellSize) {
            processedPoints++;
            const pt = turf.point([x, y]);
            if (!turf.booleanPointInPolygon(pt, waterMask)) continue;
            const isInConstraint = constraints.some(feature => {
              try {
                return turf.booleanPointInPolygon(pt, feature);
              } catch (e) {
                return true;
              }
            });
            if (!isInConstraint) grid.push(pt);
            if (processedPoints % 20 === 0) {
              await updateProgress(30 + Math.floor((processedPoints / totalPoints) * 40), `Processing grid points (${grid.length} valid so far)`);
            }
          }
        }
        await updateProgress(70, `Creating polygons from ${grid.length} points...`);
        if (grid.length === 0) throw new Error('No valid points found for cleaning zones');
        const buffers = grid.map(pt => turf.buffer(pt, 0.007, { units: 'degrees' }));
        await updateProgress(80, 'Merging zones...');
        let mergedPolygon = buffers[0];
        const batchSize = 10;
        for (let i = 1; i < buffers.length; i += batchSize) {
          const batch = buffers.slice(i, Math.min(i + batchSize, buffers.length));
          for (const buffer of batch) {
            try {
              mergedPolygon = turf.union(mergedPolygon, buffer);
            } catch (e) { }
          }
          await updateProgress(80 + Math.floor((i / buffers.length) * 15), `Merging zones (${Math.min(i + batchSize, buffers.length)}/${buffers.length})`);
        }
        await updateProgress(95, 'Finalizing zone boundaries...');
        const cleanedPolygon = turf.intersect(mergedPolygon, waterMask);
        if (!cleanedPolygon) throw new Error('Failed to clean zone boundaries');
        const landUnion = ENHANCED_COASTLINE.features.reduce((acc, f) => turf.union(acc, f));
        const bufferedLand = turf.buffer(landUnion, 0.02, { units: 'degrees' });
        const finalPolygon = turf.difference(cleanedPolygon, bufferedLand);
        if (!finalPolygon) throw new Error('All resulting polygons are on land');
        const result = {
          type: 'FeatureCollection',
          features: [{
            type: 'Feature',
            properties: {
              type: 'Potential Cleaning Zone',
              description: 'Areas outside all constraint zones (water only)',
              calculatedAt: new Date().toISOString(),
              calculationType: 'client-side',
              validPoints: grid.length
            },
            geometry: finalPolygon.geometry
          }]
        };
        cachedData.recommendedZones = result;
        saveToLocalStorage('recommendedZones', result);
        await updateProgress(100, `Calculation completed in ${Math.floor((Date.now() - startTime) / 1000)} seconds`);
        setTimeout(() => {
          if (calculationStatus) calculationStatus.style.display = 'none';
          updateRecommendedZonesLayer(result);
          showSuccessMessage('Recommended zones calculated successfully!');
        }, 1000);
        return result;
      } catch (error) {
        const calculationStatus = document.getElementById('zoneCalculationStatus');
        if (calculationStatus) {
          calculationStatus.innerHTML = `<div style="color: #e53935; margin-top: 10px;">Error calculating zones: ${error.message}<button id="retryZoneCalculation" class="retry-button">Retry</button></div>`;
          document.getElementById('retryZoneCalculation')?.addEventListener('click', () => {
            calculationStatus.style.display = 'none';
            loadRecommendedZones();
          });
        }
        throw error;
      }
    }
  </script>
</body>

</html>