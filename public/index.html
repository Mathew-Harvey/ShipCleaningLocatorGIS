<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Hull Cleaning Constraints Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" crossorigin="" />
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: Arial, sans-serif;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    #sidebar {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1000;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      max-width: 350px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .constraint-group {
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #eee;
    }

    .constraint-group h4 {
      margin: 5px 0;
      color: #333;
    }

    .layer-control {
      margin: 5px 0;
    }

    .layer-control label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      font-size: 0.9em;
    }

    .layer-control-loading {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .layer-control-loading:after {
      content: " (loading...)";
      font-style: italic;
      color: #666;
    }

    .legend {
      margin-top: 20px;
      padding-top: 10px;
      border-top: 2px solid #ccc;
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin: 5px 0;
      font-size: 0.85em;
    }

    .legend-color {
      width: 20px;
      height: 20px;
      margin-right: 8px;
      border: 1px solid #999;
      border-radius: 3px;
    }

    .info-text {
      font-size: 0.9em;
      color: #666;
      margin: 10px 0;
      padding: 10px;
      background: #f5f5f5;
      border-radius: 4px;
    }

    #loadingOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 3000;
      font-family: sans-serif;
      text-align: center;
      padding: 20px;
    }

    .spinner {
      border: 8px solid #f3f3f3;
      border-top: 8px solid #673AB7;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    .dot-animation:after {
      content: '.';
      animation: dots 1.5s steps(5, end) infinite;
    }

    @keyframes dots {

      0%,
      20% {
        content: '.';
      }

      40% {
        content: '..';
      }

      60% {
        content: '...';
      }

      80%,
      100% {
        content: '';
      }
    }

    #loadingMessage {
      font-size: 1.1em;
      color: #333;
    }

    #loadingSubMessage {
      font-size: 0.85em;
      color: #666;
      margin-top: 10px;
      max-width: 80%;
    }

    #progressBar {
      width: 80%;
      max-width: 300px;
      height: 10px;
      background-color: #f3f3f3;
      border-radius: 5px;
      margin-top: 15px;
      overflow: hidden;
    }

    #progressFill {
      height: 100%;
      width: 0%;
      background-color: #673AB7;
      transition: width 0.5s ease;
    }

    #analysisContainer {
      display: none;
      position: fixed;
      left: 20px;
      bottom: 20px;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      max-width: 400px;
      max-height: 60vh;
      overflow-y: auto;
      z-index: 1500;
    }

    #analysisClose {
      position: absolute;
      top: 10px;
      right: 10px;
      cursor: pointer;
      font-size: 18px;
      color: #666;
    }

    #analysisContent {
      margin-top: 10px;
    }

    .analysis-item {
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid #eee;
    }

    .analysis-item:last-child {
      border-bottom: none;
    }

    .analysis-header {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }

    .analysis-icon {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .analysis-title {
      font-weight: bold;
      font-size: 0.95em;
    }

    .analysis-detail {
      margin-left: 20px;
      font-size: 0.85em;
      color: #555;
    }

    .analysis-warning {
      color: #e53935;
      font-weight: bold;
    }

    .analysis-good {
      color: #43a047;
      font-weight: bold;
    }

    .nautical-reference {
      font-size: 0.9em;
      background-color: #f0f8ff;
      padding: 6px;
      margin-bottom: 6px;
      border-left: 3px solid #0066CC;
    }

    #errorToast {
      display: none;
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #f44336;
      color: white;
      padding: 12px 20px;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      z-index: 3100;
      font-size: 14px;
    }

    .analysis-marker {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: rgba(103, 58, 183, 0.8);
      color: white;
      font-weight: bold;
      border: 2px solid white;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    }

    .navigation-aids,
    .vessel-icon,
    .weather-icon,
    .warning-icon,
    .depth-label,
    .sea-mark-icon {
      background: transparent;
      border: none;
    }

    .depth-label {
      font-weight: bold;
      text-shadow: 0px 0px 2px white;
    }

    .sea-mark-icon {
      filter: drop-shadow(0px 0px 1px white);
    }

    /* Status indicator styles */
    #serverStatus {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.8);
      padding: 5px 10px;
      border-radius: 15px;
      font-size: 12px;
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
    }

    .status-connecting {
      background-color: #FFA000;
    }

    .status-online {
      background-color: #4CAF50;
    }

    .status-offline {
      background-color: #F44336;
    }

    .status-degraded {
      background-color: #FF9800;
    }

    .retry-button {
      background-color: #673AB7;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 16px;
      font-size: 14px;
      cursor: pointer;
      margin-top: 15px;
    }

    .retry-button:hover {
      background-color: #5E35B1;
    }

    /* Improved depth contour styles */
    .depth-contour-5 {
      color: #a5ddff;
      stroke: #a5ddff;
      stroke-width: 2px;
    }

    .depth-contour-10 {
      color: #77c3ec;
      stroke: #77c3ec;
      stroke-width: 2px;
    }

    .depth-contour-15 {
      color: #5ba3d0;
      stroke: #5ba3d0;
      stroke-width: 2px;
    }

    .depth-contour-20 {
      color: #3d83b3;
      stroke: #3d83b3;
      stroke-width: 2px;
    }

    .depth-contour-30 {
      color: #2064a0;
      stroke: #2064a0;
      stroke-width: 2px;
    }

    .depth-contour-50 {
      color: #1a4989;
      stroke: #1a4989;
      stroke-width: 2px;
    }

    /* Navigation aids */
    .buoy-port {
      color: #FF0000;
      font-size: 22px;
    }

    .buoy-starboard {
      color: #00AA00;
      font-size: 22px;
    }

    .lighthouse {
      color: #000000;
      font-size: 22px;
    }

    .anchorage {
      color: #0066CC;
      font-size: 20px;
    }

    .danger {
      color: #FF0000;
      font-size: 20px;
    }

    /* Water jurisdiction styling */
    .state-waters {
      stroke: #4169E1;
      stroke-width: 3px;
      stroke-dasharray: 5, 5;
      fill: #4169E1;
      fill-opacity: 0.1;
    }

    .commonwealth-waters {
      stroke: #191970;
      stroke-width: 3px;
      stroke-dasharray: 10, 5;
      fill: #191970;
      fill-opacity: 0.1;
    }

    /* Military areas */
    .military-area {
      stroke: #8B0000;
      stroke-width: 2px;
      fill: #8B0000;
      fill-opacity: 0.2;
    }

    .military-zone-marker {
      color: #8B0000;
      font-size: 22px;
    }

    /* Marine geomorphic features */
    .geomorphic-feature {
      stroke: #008080;
      stroke-width: 2px;
      fill: #008080;
      fill-opacity: 0.15;
    }

    /* Zone calculation status styles */
    .calculation-status {
      background: #f5f8ff;
      border-left: 4px solid #673AB7;
      padding: 8px 12px;
      margin: 8px 0;
      font-size: 13px;
      border-radius: 0 4px 4px 0;
    }

    .calculation-progress {
      font-weight: bold;
      color: #673AB7;
    }

    .calculation-time {
      font-size: 12px;
      color: #666;
      margin-top: 4px;
    }

    /* Fallback zone styling */
    .fallback-zone-alert {
      background: #fff8e1;
      border-left: 4px solid #FFA000;
      padding: 10px;
      margin: 8px 0;
      font-size: 13px;
      border-radius: 0 4px 4px 0;
      position: absolute;
      top: 80px;
      left: 10px;
      z-index: 1000;
      max-width: 300px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    }

    /* Multiple fallback zones */
    .fallback-zone-north {
      color: #673AB7;
      stroke: #673AB7;
      stroke-width: 2px;
      stroke-dasharray: 5, 5;
      fill: #673AB7;
      fill-opacity: 0.2;
    }

    .fallback-zone-west {
      color: #2196F3;
      stroke: #2196F3;
      stroke-width: 2px;
      stroke-dasharray: 5, 5;
      fill: #2196F3;
      fill-opacity: 0.2;
    }

    .fallback-zone-south {
      color: #4CAF50;
      stroke: #4CAF50;
      stroke-width: 2px;
      stroke-dasharray: 5, 5;
      fill: #4CAF50;
      fill-opacity: 0.2;
    }

    /* Add these to the existing <style> section */
    .layer-control-error {
      opacity: 0.8;
      background-color: #fff5f5;
      border-radius: 4px;
      padding: 2px 4px;
    }

    .layer-control-error:after {
      content: " (error)";
      font-style: italic;
      color: #e53935;
    }

    .layer-error-message {
      font-size: 0.8em;
      color: #e53935;
      margin-left: 24px;
      font-style: italic;
    }

    .layer-retry-button {
      margin-left: 24px;
      font-size: 0.8em;
      background-color: #673AB7;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 2px 6px;
      cursor: pointer;
      margin-top: 2px;
    }

    .layer-retry-button:hover {
      background-color: #5E35B1;
    }
  </style>
</head>

<body>
  <div id="loadingOverlay">
    <div class="spinner"></div>
    <div id="loadingMessage" class="dot-animation">Loading marine data</div>
    <div id="loadingSubMessage">This map is running on a free server which may take a minute to wake up if it hasn't
      been used recently. Thank you for your patience.</div>
    <div id="progressBar">
      <div id="progressFill"></div>
    </div>
  </div>
  <div id="errorToast"></div>
  <div id="analysisContainer">
    <span id="analysisClose">×</span>
    <h3>Location Analysis</h3>
    <div id="analysisContent"></div>
  </div>
  <div id="confirmationModal"
    style="display: none; position: fixed; z-index: 2500; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5);">
    <div
      style="background-color: white; margin: 15% auto; padding: 20px; border-radius: 8px; width: 300px; text-align: center; box-shadow: 0 4px 8px rgba(0,0,0,0.2);">
      <h4 style="margin-top: 0;">Location Analysis</h4>
      <p>Would you like to generate a report for this location?</p>
      <div style="display: flex; justify-content: center; gap: 10px;">
        <button id="confirmYes"
          style="padding: 8px 16px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Yes</button>
        <button id="confirmNo"
          style="padding: 8px 16px; background-color: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">No</button>
      </div>
    </div>
  </div>
  <div id="map"></div>
  <div id="sidebar">
    <h3>Hull Cleaning Constraints</h3>
    <div class="info-text">
      To select potential cleaning sites, ensure the location:
      <ul>
        <li>Is outside Fremantle Port limits</li>
        <li>Has minimal proximity to sensitive receptors (marine parks, fish habitat, Cockburn Sound protection, etc.)
        </li>
        <li>Offers sufficient water flow for safe dispersion of residuals</li>
      </ul>
      Areas shown in the "Potential Cleaning Zones" layer represent parts of the study area that do not intersect with
      restricted zones.
      <p><em>Click anywhere on the map to analyze a potential cleaning location.</em></p>
    </div>
    <div class="constraint-group">
      <h4>Jurisdictional</h4>
      <div class="layer-control layer-control-loading">
        <label><input type="checkbox" id="portAuthoritiesCheckbox" checked> Port Authority Areas</label>
      </div>
      <div class="constraint-group">
        <h4>Environmental Protection</h4>
        <div class="layer-control layer-control-loading">
          <label><input type="checkbox" id="marineParksCheckbox" checked> Marine Parks & Reserves</label>
        </div>
        <div class="layer-control layer-control-loading">
          <label><input type="checkbox" id="fishHabitatCheckbox" checked> Fish Habitat Protection Areas</label>
        </div>
        <div class="layer-control layer-control-loading">
          <label><input type="checkbox" id="cockburnSoundCheckbox" checked> Cockburn Sound Protection Area</label>
        </div>
      </div>
      <div class="constraint-group">
        <h4>Infrastructure & Restricted Areas</h4>
        <div class="layer-control layer-control-loading">
          <label><input type="checkbox" id="mooringAreasCheckbox" checked> Mooring Control Areas</label>
        </div>
        <div class="layer-control layer-control-loading">
          <label><input type="checkbox" id="marineInfrastructureCheckbox" checked> Marine Infrastructure</label>
        </div>
      </div>
      <div class="constraint-group">
        <h4>Recommended Cleaning Zones</h4>
        <div class="layer-control layer-control-loading">
          <label><input type="checkbox" id="recommendedZonesCheckbox" checked> Potential Cleaning Zones</label>
        </div>
        <div id="zoneCalculationStatus" class="calculation-status" style="display: none;">
          <div>Calculating recommended zones: <span id="calculationProgress" class="calculation-progress">0%</span>
          </div>
          <div id="calculationTime" class="calculation-time"></div>
        </div>
      </div>
      <div class="constraint-group">
        <h4>Nautical Overlays</h4>
        <div class="layer-control layer-control-loading">
          <label><input type="checkbox" id="navigationAidsCheckbox" checked> Navigation Aids</label>
        </div>
        <div class="layer-control">
          <label><input type="checkbox" id="marineTrafficCheckbox"> Marine Traffic (AIS)</label>
        </div>
        <div class="layer-control">
          <label><input type="checkbox" id="weatherCheckbox"> Weather & Wind</label>
        </div>
        <div class="layer-control">
          <label><input type="checkbox" id="navigationalWarningsCheckbox"> Navigational Warnings</label>
        </div>
        <div class="layer-control layer-control-loading">
          <label><input type="checkbox" id="bathymetryCheckbox" checked> Bathymetry (Depth Contours)</label>
        </div>
        <div class="layer-control layer-control-loading">
          <label><input type="checkbox" id="marineMultibeamCheckbox"> High-Resolution Bathymetry</label>
        </div>
      </div>
      <div class="legend">
        <h4>Legend</h4>
        <div class="legend-item">
          <div class="legend-color" style="background: #FF4081"></div> Port Authority Areas
        </div>
        <div class="legend-item">
          <div class="legend-item">
            <div class="legend-color" style="background: #4CAF50"></div> Marine Parks & Reserves
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: #FF9800"></div> Fish Habitat Areas
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: #2196F3"></div> Cockburn Sound
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: #008080"></div> Marine Geomorphic Features
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: #9C27B0"></div> Mooring Areas
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: #795548"></div> Marine Infrastructure
          </div>
          <div class="legend-item">
            <div class="legend-item">
              <div class="legend-color" style="background: #673AB7"></div> Potential Cleaning Zones
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background: #000"></div> Navigation Aids
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background: #FF5500"></div> Marine Traffic (AIS)
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background: #00AAFF"></div> Weather & Wind
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background: #FF0000"></div> Navigational Warnings
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background: #3d83b3"></div> Bathymetry (Depth Contours)
            </div>
          </div>
        </div>

        <div id="serverStatus">
          <span class="status-dot status-connecting"></span>
          <span id="statusText">Connecting to server...</span>
        </div>

        <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js" crossorigin=""></script>
        <script>
          // Configuration
          const API_CONFIG = {
            local: 'http://localhost:3000',
            production: 'https://shipcleaninggis-server.onrender.com',
            mockMode: true // Set to false in production if server is reliable
          };

          // Determine environment
          const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
          const apiBaseUrl = isLocalhost ? API_CONFIG.local : API_CONFIG.production;

          // Client-side fallback data
          const FALLBACK_DATA = {
            type: 'FeatureCollection',
            features: []
          };

          // Standard study area for the region
          const STUDY_AREA = {
            type: 'Feature',
            properties: {
              type: 'Study Area',
              description: 'Perth coastal region near Fremantle'
            },
            geometry: {
              type: 'Polygon',
              coordinates: [
                [
                  [115.65, -32.15],
                  [115.85, -32.15],
                  [115.85, -31.95],
                  [115.65, -31.95],
                  [115.65, -32.15]
                ]
              ]
            }
          };

          // Improved fallback recommended zones with multiple areas
          const FALLBACK_RECOMMENDED_ZONES = {
            type: 'FeatureCollection',
            features: [
              {
                type: 'Feature',
                properties: {
                  type: 'Potential Cleaning Zone (Fallback)',
                  description: 'North of Fremantle - based on general knowledge of constraints',
                  confidence: 'medium',
                  note: 'This is an estimated zone (server calculation unavailable)',
                  zoneId: 'north'
                },
                geometry: {
                  type: 'Polygon',
                  coordinates: [[
                    [115.68, -31.98],
                    [115.75, -31.98],
                    [115.75, -32.02],
                    [115.68, -32.02],
                    [115.68, -31.98]
                  ]]
                }
              },
              {
                type: 'Feature',
                properties: {
                  type: 'Potential Cleaning Zone (Fallback)',
                  description: 'West of Fremantle - based on general knowledge of constraints',
                  confidence: 'medium',
                  note: 'This is an estimated zone (server calculation unavailable)',
                  zoneId: 'west'
                },
                geometry: {
                  type: 'Polygon',
                  coordinates: [[
                    [115.65, -32.04],
                    [115.70, -32.04],
                    [115.70, -32.08],
                    [115.65, -32.08],
                    [115.65, -32.04]
                  ]]
                }
              },
              {
                type: 'Feature',
                properties: {
                  type: 'Potential Cleaning Zone (Fallback)',
                  description: 'South of Fremantle - based on general knowledge of constraints',
                  confidence: 'medium',
                  note: 'This is an estimated zone (server calculation unavailable)',
                  zoneId: 'south'
                },
                geometry: {
                  type: 'Polygon',
                  coordinates: [[
                    [115.75, -32.10],
                    [115.82, -32.10],
                    [115.82, -32.14],
                    [115.75, -32.14],
                    [115.75, -32.10]
                  ]]
                }
              }
            ]
          };

          // Fallback for each layer type
          const FALLBACK_LAYERS = {
            portAuthorities: {
              type: 'FeatureCollection',
              features: [{
                type: 'Feature',
                properties: { NAME: 'Fremantle Ports', DESCRIPTION: 'Port Authority Boundary (Offline)' },
                geometry: {
                  type: 'Polygon',
                  coordinates: [
                    [
                      [115.73, -32.07],
                      [115.76, -32.07],
                      [115.76, -32.04],
                      [115.73, -32.04],
                      [115.73, -32.07]
                    ]
                  ]
                }
              }]
            },
            stateWaters: {
              type: 'FeatureCollection',
              features: [{
                type: 'Feature',
                properties: { NAME: 'WA State Waters', DESCRIPTION: 'State Waters Boundary (Offline)' },
                geometry: {
                  type: 'Polygon',
                  coordinates: [
                    [
                      [115.65, -32.10],
                      [115.80, -32.10],
                      [115.80, -32.00],
                      [115.65, -32.00],
                      [115.65, -32.10]
                    ]
                  ]
                }
              }]
            },
            commonwealthWaters: {
              type: 'FeatureCollection',
              features: [{
                type: 'Feature',
                properties: { NAME: 'Commonwealth Waters', DESCRIPTION: 'Commonwealth Waters (Offshore) (Offline)' },
                geometry: {
                  type: 'Polygon',
                  coordinates: [
                    [
                      [115.60, -32.15],
                      [115.90, -32.15],
                      [115.90, -31.90],
                      [115.60, -31.90],
                      [115.60, -32.15]
                    ]
                  ]
                }
              }]
            },
            militaryAreas: {
              type: 'FeatureCollection',
              features: [{
                type: 'Feature',
                properties: { name: 'Naval Training Zone', type: 'military', description: 'Estimated Military Exclusion Zone (Offline)' },
                geometry: {
                  type: 'Polygon',
                  coordinates: [
                    [
                      [115.72, -32.03],
                      [115.75, -32.03],
                      [115.75, -32.06],
                      [115.72, -32.06],
                      [115.72, -32.03]
                    ]
                  ]
                }
              }]
            },
            marineParks: {
              type: 'FeatureCollection',
              features: [{
                type: 'Feature',
                properties: { NAME: 'Marine Reserve', DESCRIPTION: 'Protected Marine Park (Offline)' },
                geometry: {
                  type: 'Polygon',
                  coordinates: [
                    [
                      [115.67, -32.00],
                      [115.71, -32.00],
                      [115.71, -31.97],
                      [115.67, -31.97],
                      [115.67, -32.00]
                    ]
                  ]
                }
              }]
            },
            fishHabitat: {
              type: 'FeatureCollection',
              features: [{
                type: 'Feature',
                properties: { NAME: 'Fish Habitat Zone', DESCRIPTION: 'Protected Fish Habitat (Offline)' },
                geometry: {
                  type: 'Polygon',
                  coordinates: [
                    [
                      [115.78, -32.05],
                      [115.82, -32.05],
                      [115.82, -32.02],
                      [115.78, -32.02],
                      [115.78, -32.05]
                    ]
                  ]
                }
              }]
            },
            cockburnSound: {
              type: 'FeatureCollection',
              features: [{
                type: 'Feature',
                properties: { NAME: 'Cockburn Sound', DESCRIPTION: 'Cockburn Sound Protection Area (Offline)' },
                geometry: {
                  type: 'Polygon',
                  coordinates: [
                    [
                      [115.74, -32.12],
                      [115.79, -32.12],
                      [115.79, -32.08],
                      [115.74, -32.08],
                      [115.74, -32.12]
                    ]
                  ]
                }
              }]
            },
            marineGeomorphic: {
              type: 'FeatureCollection',
              features: [{
                type: 'Feature',
                properties: { name: 'Offshore Bank', type: 'bank', description: 'Geomorphic Feature (Offline)' },
                geometry: {
                  type: 'Polygon',
                  coordinates: [
                    [
                      [115.64, -32.08],
                      [115.69, -32.08],
                      [115.69, -32.05],
                      [115.64, -32.05],
                      [115.64, -32.08]
                    ]
                  ]
                }
              }]
            },
            mooringAreas: {
              type: 'FeatureCollection',
              features: [{
                type: 'Feature',
                properties: { NAME: 'Mooring Area', DESCRIPTION: 'Designated Mooring Zone (Offline)' },
                geometry: {
                  type: 'Polygon',
                  coordinates: [
                    [
                      [115.72, -32.03],
                      [115.74, -32.03],
                      [115.74, -32.01],
                      [115.72, -32.01],
                      [115.72, -32.03]
                    ]
                  ]
                }
              }]
            },
            marineInfrastructure: {
              type: 'FeatureCollection',
              features: [{
                type: 'Feature',
                properties: { NAME: 'Marine Structure', DESCRIPTION: 'Underwater Infrastructure (Offline)' },
                geometry: {
                  type: 'Polygon',
                  coordinates: [
                    [
                      [115.75, -32.06],
                      [115.76, -32.06],
                      [115.76, -32.05],
                      [115.75, -32.05],
                      [115.75, -32.06]
                    ]
                  ]
                }
              }]
            },
            marineMultibeam: {
              type: 'FeatureCollection',
              features: [{
                type: 'Feature',
                properties: { name: 'Multibeam Survey Area', description: 'High-Resolution Bathymetry Survey (Offline)' },
                geometry: {
                  type: 'Polygon',
                  coordinates: [
                    [
                      [115.73, -32.06],
                      [115.77, -32.06],
                      [115.77, -32.04],
                      [115.73, -32.04],
                      [115.73, -32.06]
                    ]
                  ]
                }
              }]
            }
          };

          // Improved navigation aids data for nautical chart
          const NAVIGATION_AIDS = {
            type: 'FeatureCollection',
            features: [
              // Lights and lighthouses
              {
                type: 'Feature',
                properties: {
                  name: 'Fremantle Lighthouse',
                  type: 'lighthouse',
                  characteristics: 'Fl W 10s 30m 19M',
                  description: 'Main lighthouse at Fremantle Port entrance'
                },
                geometry: {
                  type: 'Point',
                  coordinates: [115.745, -32.045]
                }
              },
              {
                type: 'Feature',
                properties: {
                  name: 'Success Harbour Light',
                  type: 'lighthouse',
                  characteristics: 'Fl G 3s 12m 8M',
                  description: 'Green sector light marking entrance to Success Harbour'
                },
                geometry: {
                  type: 'Point',
                  coordinates: [115.762, -32.107]
                }
              },
              // Port buoys (red)
              {
                type: 'Feature',
                properties: {
                  name: 'No. 2 Port Entrance Buoy',
                  type: 'buoy-port',
                  characteristics: 'Fl R 2.5s',
                  description: 'Port (left) side entrance marker'
                },
                geometry: {
                  type: 'Point',
                  coordinates: [115.739, -32.052]
                }
              },
              {
                type: 'Feature',
                properties: {
                  name: 'No. 4 Port Channel Buoy',
                  type: 'buoy-port',
                  characteristics: 'Fl R 5s',
                  description: 'Port channel marker'
                },
                geometry: {
                  type: 'Point',
                  coordinates: [115.730, -32.048]
                }
              },
              // Starboard buoys (green)
              {
                type: 'Feature',
                properties: {
                  name: 'No. 1 Starboard Entrance Buoy',
                  type: 'buoy-starboard',
                  characteristics: 'Fl G 2.5s',
                  description: 'Starboard (right) side entrance marker'
                },
                geometry: {
                  type: 'Point',
                  coordinates: [115.738, -32.055]
                }
              },
              {
                type: 'Feature',
                properties: {
                  name: 'No. 3 Starboard Channel Buoy',
                  type: 'buoy-starboard',
                  characteristics: 'Fl G 5s',
                  description: 'Starboard channel marker'
                },
                geometry: {
                  type: 'Point',
                  coordinates: [115.730, -32.050]
                }
              },
              // Anchorages
              {
                type: 'Feature',
                properties: {
                  name: 'Gage Roads Anchorage Alpha',
                  type: 'anchorage',
                  characteristics: 'Large vessels',
                  description: 'Primary anchorage for commercial vessels'
                },
                geometry: {
                  type: 'Point',
                  coordinates: [115.685, -32.020]
                }
              },
              {
                type: 'Feature',
                properties: {
                  name: 'Gage Roads Anchorage Bravo',
                  type: 'anchorage',
                  characteristics: 'Small vessels',
                  description: 'Secondary anchorage'
                },
                geometry: {
                  type: 'Point',
                  coordinates: [115.695, -32.030]
                }
              },
              // Hazards and dangers
              {
                type: 'Feature',
                properties: {
                  name: 'Parmelia Bank Shoal',
                  type: 'danger',
                  characteristics: 'Depth 3.5m',
                  description: 'Shallow area - navigational hazard'
                },
                geometry: {
                  type: 'Point',
                  coordinates: [115.750, -32.065]
                }
              },
              {
                type: 'Feature',
                properties: {
                  name: 'Submerged Rock',
                  type: 'danger',
                  characteristics: 'Depth 2.7m',
                  description: 'Isolated danger'
                },
                geometry: {
                  type: 'Point',
                  coordinates: [115.725, -32.075]
                }
              }
            ]
          };

          // NAUTICAL_REFERENCES for offline mode
          const NAUTICAL_REFERENCES = {
            type: 'FeatureCollection',
            features: [
              {
                type: 'Feature',
                properties: {
                  name: 'Fremantle Harbour Entrance',
                  type: 'harbour_entrance',
                  description: 'Main entrance to Fremantle Port'
                },
                geometry: {
                  type: 'Point',
                  coordinates: [115.739, -32.055]
                }
              },
              {
                type: 'Feature',
                properties: {
                  name: 'Rottnest Island',
                  type: 'island',
                  description: 'Major island west of Fremantle'
                },
                geometry: {
                  type: 'Point',
                  coordinates: [115.52, -32.00]
                }
              },
              {
                type: 'Feature',
                properties: {
                  name: 'Success Harbour',
                  type: 'harbour',
                  description: 'Protected harbour in Cockburn Sound'
                },
                geometry: {
                  type: 'Point',
                  coordinates: [115.763, -32.107]
                }
              },
              {
                type: 'Feature',
                properties: {
                  name: 'Gage Roads',
                  type: 'anchorage',
                  description: 'Main ship anchorage area'
                },
                geometry: {
                  type: 'Point',
                  coordinates: [115.68, -32.03]
                }
              }
            ]
          };

          let map;
          let currentMarker = null;
          let tempClickLocation = null;
          let serverOnline = false;
          let loadingStartTime;
          let cachedData = {};

          // Progress tracking
          let totalLoadItems = 9; // Updated number of layers to load (removed 3 layers)
          let loadedItems = 0;
          let progressInterval;
          let serverWakeupAttempts = 0;
          const MAX_WAKEUP_ATTEMPTS = 3;

          // Zone calculation status tracking
          let zoneCalculationPolling = null;
          let zoneCalculationStartTime = null;
          let zoneCalculationRetries = 0;
          const MAX_ZONE_CALCULATION_RETRIES = 3;

          // Active layer keys (removed stateWaters, commonwealthWaters, militaryAreas)
          const activeLayerKeys = [
            'portAuthorities',
            'marineParks',
            'fishHabitat',
            'cockburnSound',
            'mooringAreas',
            'marineInfrastructure',
            'marineGeomorphic',
            'marineMultibeam',
            'recommendedZones'
          ];

          // Layer definitions with styles
          const govLayers = {
            // Original layers
            portAuthorities: { url: `/api/portAuthorities`, style: { color: '#FF4081', weight: 2, opacity: 0.8, fillOpacity: 0.2 }, layer: null },
            marineParks: { url: `/api/marineParks`, style: { color: '#4CAF50', weight: 2, opacity: 0.8, fillOpacity: 0.2 }, layer: null },
            fishHabitat: { url: `/api/fishHabitat`, style: { color: '#FF9800', weight: 2, opacity: 0.8, fillOpacity: 0.2 }, layer: null },
            cockburnSound: { url: `/api/cockburnSound`, style: { color: '#2196F3', weight: 2, opacity: 0.8, fillOpacity: 0.2 }, layer: null },
            mooringAreas: { url: `/api/mooringAreas`, style: { color: '#9C27B0', weight: 2, opacity: 0.8, fillOpacity: 0.2 }, layer: null },
            marineInfrastructure: { url: `/api/marineInfrastructure`, style: { color: '#795548', weight: 2, opacity: 0.8, fillOpacity: 0.2 }, layer: null },

            // New layers from Geoscience Australia
            stateWaters: { url: `/api/stateWaters`, style: { className: 'state-waters', color: '#4169E1', weight: 3, opacity: 0.8, fillOpacity: 0.1, dashArray: '5,5' }, layer: null },
            commonwealthWaters: { url: `/api/commonwealthWaters`, style: { className: 'commonwealth-waters', color: '#191970', weight: 3, opacity: 0.8, fillOpacity: 0.1, dashArray: '10,5' }, layer: null },
            marineGeomorphic: { url: `/api/marineGeomorphic`, style: { className: 'geomorphic-feature', color: '#008080', weight: 2, opacity: 0.8, fillOpacity: 0.15 }, layer: null },
            marineMultibeam: { url: `/api/marineMultibeam`, style: { color: '#006400', weight: 2, opacity: 0.8, fillOpacity: 0.2 }, layer: null },
            militaryAreas: { url: `/api/militaryAreas`, style: { className: 'military-area', color: '#8B0000', weight: 2, opacity: 0.8, fillOpacity: 0.2 }, layer: null },

            // Recommended zones
            recommendedZones: { url: `/api/recommendedZones`, style: { color: '#673AB7', weight: 2, opacity: 0.8, fillOpacity: 0.2 }, layer: null }
          };

          const layerColors = {
            portAuthorities: '#FF4081',
            marineParks: '#4CAF50',
            fishHabitat: '#FF9800',
            cockburnSound: '#2196F3',
            mooringAreas: '#9C27B0',
            marineInfrastructure: '#795548',
            stateWaters: '#4169E1',
            commonwealthWaters: '#191970',
            marineGeomorphic: '#008080',
            marineMultibeam: '#006400',
            militaryAreas: '#8B0000',
            recommendedZones: '#673AB7'
          };

          // Local storage helpers
          function saveToLocalStorage(key, data) {
            try {
              // Calculate approximate size
              const serialized = JSON.stringify(data);
              const sizeInKB = serialized.length / 1024;

              // Skip if data is too large (>6MB)
              if (sizeInKB > 6000) {
                console.warn(`Data for ${key} too large for localStorage (${sizeInKB.toFixed(2)}KB)`);
                return false;
              }

              // For GeoJSON, store simplified version to save space
              if (data.type === 'FeatureCollection' && Array.isArray(data.features)) {
                // Simple simplification: reduce precision of coordinates
                const simplified = {
                  type: 'FeatureCollection',
                  features: data.features.map(feature => {
                    if (!feature.geometry) return feature;

                    // Only keep essential properties
                    const properties = {};
                    if (feature.properties) {
                      ['name', 'NAME', 'Name', 'type', 'depth', 'description'].forEach(prop => {
                        if (feature.properties[prop] !== undefined) {
                          properties[prop] = feature.properties[prop];
                        }
                      });
                    }

                    return {
                      type: 'Feature',
                      properties,
                      geometry: feature.geometry
                    };
                  }).slice(0, 100) // Limit to 100 features max
                };

                localStorage.setItem(`gisapp_${key}`, JSON.stringify({
                  timestamp: Date.now(),
                  data: simplified
                }));
              } else {
                localStorage.setItem(`gisapp_${key}`, JSON.stringify({
                  timestamp: Date.now(),
                  data: data
                }));
              }
              return true;
            } catch (error) {
              console.warn('Failed to save to localStorage:', error);
              // If quota exceeded, try to clear old items
              if (error.name === 'QuotaExceededError') {
                try {
                  // Clean up old cached items
                  const keysToRemove = [];
                  for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith('gisapp_')) {
                      keysToRemove.push(key);
                    }
                  }
                  // Sort by timestamp if available and remove oldest
                  keysToRemove.sort((a, b) => {
                    try {
                      const itemA = JSON.parse(localStorage.getItem(a));
                      const itemB = JSON.parse(localStorage.getItem(b));
                      return (itemA.timestamp || 0) - (itemB.timestamp || 0);
                    } catch (e) {
                      return 0;
                    }
                  });
                  // Remove oldest 50%
                  const removeCount = Math.ceil(keysToRemove.length / 2);
                  keysToRemove.slice(0, removeCount).forEach(k => localStorage.removeItem(k));
                } catch (e) {
                  console.warn('Failed to clean localStorage:', e);
                }
              }
              return false;
            }
          }

          function getFromLocalStorage(key, maxAgeHours = 24) {
            try {
              const stored = localStorage.getItem(`gisapp_${key}`);
              if (!stored) return null;

              const parsed = JSON.parse(stored);
              const ageHours = (Date.now() - parsed.timestamp) / (1000 * 60 * 60);

              if (ageHours > maxAgeHours) {
                localStorage.removeItem(`gisapp_${key}`);
                return null;
              }

              return parsed.data;
            } catch (error) {
              console.warn('Failed to retrieve from localStorage:', error);
              return null;
            }
          }

          // Error and status display functions
          function showError(message, duration = 5000) {
            const toast = document.getElementById('errorToast');
            toast.textContent = message;
            toast.style.display = 'block';
            setTimeout(() => toast.style.display = 'none', duration);
          }

          function updateServerStatus(status, message) {
            const statusDot = document.querySelector('.status-dot');
            const statusText = document.getElementById('statusText');

            // Remove all status classes and add the appropriate one
            statusDot.classList.remove('status-connecting', 'status-online', 'status-offline', 'status-degraded');

            switch (status) {
              case 'connecting':
                statusDot.classList.add('status-connecting');
                break;
              case 'online':
                statusDot.classList.add('status-online');
                serverOnline = true;
                break;
              case 'offline':
                statusDot.classList.add('status-offline');
                serverOnline = false;
                break;
              case 'degraded':
                statusDot.classList.add('status-degraded');
                serverOnline = true;
                break;
            }

            statusText.textContent = message || status;
          }

          function updateLoadingProgress() {
            const progressFill = document.getElementById('progressFill');
            const progress = Math.min((loadedItems / totalLoadItems) * 100, 100);
            progressFill.style.width = `${progress}%`;
          }

          function updateLegend() {
  const legendContainer = document.querySelector('.legend');
  if (!legendContainer) return;
  
  // Clear existing legend items
  const existingItems = legendContainer.querySelectorAll('.legend-item');
  existingItems.forEach(item => item.remove());
  
  // Add header back if it was removed
  if (!legendContainer.querySelector('h4')) {
    const header = document.createElement('h4');
    header.textContent = 'Legend';
    legendContainer.appendChild(header);
  }
  
  // Add legend items for active layers
  const activeItems = [
    { key: 'portAuthorities', color: '#FF4081', label: 'Port Authority Areas' },
    { key: 'marineParks', color: '#4CAF50', label: 'Marine Parks & Reserves' },
    { key: 'fishHabitat', color: '#FF9800', label: 'Fish Habitat Areas' },
    { key: 'cockburnSound', color: '#2196F3', label: 'Cockburn Sound' },
    { key: 'marineGeomorphic', color: '#008080', label: 'Marine Geomorphic Features' },
    { key: 'mooringAreas', color: '#9C27B0', label: 'Mooring Areas' },
    { key: 'marineInfrastructure', color: '#795548', label: 'Marine Infrastructure' },
    { key: 'recommendedZones', color: '#673AB7', label: 'Potential Cleaning Zones' },
    { key: 'navigationAids', color: '#000', label: 'Navigation Aids' },
    { key: 'marineTraffic', color: '#FF5500', label: 'Marine Traffic (AIS)' },
    { key: 'weather', color: '#00AAFF', label: 'Weather & Wind' },
    { key: 'navigationalWarnings', color: '#FF0000', label: 'Navigational Warnings' },
    { key: 'bathymetry', color: '#3d83b3', label: 'Bathymetry (Depth Contours)' }
  ];
  
  activeItems.forEach(item => {
    const legendItem = document.createElement('div');
    legendItem.className = 'legend-item';
    legendItem.innerHTML = `
      <div class="legend-color" style="background: ${item.color}"></div> ${item.label}
    `;
    legendContainer.appendChild(legendItem);
  });
}

          // Updated function to display error state and add retry button
          function updateLayerLoadingState(key, isLoading, error = null) {
            const control = document.querySelector(`#${key}Checkbox`);
            if (control) {
              const parent = control.closest('.layer-control');
              if (parent) {
                // Remove all state classes
                parent.classList.remove('layer-control-loading', 'layer-control-error');

                // Add appropriate class
                if (isLoading) {
                  parent.classList.add('layer-control-loading');
                } else if (error) {
                  parent.classList.add('layer-control-error');

                  // Add error message
                  let errorMsg = parent.querySelector('.layer-error-message');
                  if (!errorMsg) {
                    errorMsg = document.createElement('div');
                    errorMsg.className = 'layer-error-message';
                    parent.appendChild(errorMsg);
                  }
                  errorMsg.textContent = 'Unable to load data';

                  // Add retry button if not already present
                  let retryBtn = parent.querySelector('.layer-retry-button');
                  if (!retryBtn) {
                    retryBtn = document.createElement('button');
                    retryBtn.className = 'layer-retry-button';
                    retryBtn.textContent = 'Retry';
                    retryBtn.addEventListener('click', (e) => {
                      e.stopPropagation();
                      retryLoadLayer(key);
                    });
                    parent.appendChild(retryBtn);
                  }
                }
              }
            }

            // Update loading progress
            if (!isLoading) {
              loadedItems++;
              updateLoadingProgress();
            }
          }

          // New function to retry loading a specific layer
          async function retryLoadLayer(key) {
            if (!govLayers[key]) return;

            try {
              const layerControl = document.querySelector(`#${key}Checkbox`).closest('.layer-control');
              // Clear existing error state
              const errorMsg = layerControl.querySelector('.layer-error-message');
              if (errorMsg) errorMsg.remove();

              // Show loading state
              updateLayerLoadingState(key, true);

              // Clear cached data for this layer to force a fresh fetch
              delete cachedData[key];

              // Fetch the layer data
              const data = await fetchLayerData(govLayers[key].url, key);

              // Create the layer
              if (govLayers[key].layer) {
                map.removeLayer(govLayers[key].layer);
              }

              govLayers[key].layer = L.geoJSON(data, {
                style: govLayers[key].style,
                onEachFeature: (feature, layer) => {
                  if (feature.properties) {
                    const popupContent = Object.entries(feature.properties)
                      .map(([prop, value]) => `<strong>${prop}:</strong> ${value}`)
                      .join('<br>');
                    layer.bindPopup(popupContent);
                  }
                }
              }).addTo(map);

              govLayers[key].layer.on('click', e => {
                L.DomEvent.stopPropagation(e);
                tempClickLocation = e.latlng;
                document.getElementById('confirmationModal').style.display = 'block';
              });

              // Update layer state
              updateLayerLoadingState(key, false);

              // Remove retry button
              const retryBtn = layerControl.querySelector('.layer-retry-button');
              if (retryBtn) retryBtn.remove();

            } catch (error) {
              console.error(`Error retrying layer ${key}:`, error);
              updateLayerLoadingState(key, false, error);
              showError(`Failed to load ${key} data. Please try again.`);
            }
          }

          function updateLoadingMessage(message, showProgress = true) {
            const loadingMsg = document.getElementById('loadingMessage');
            loadingMsg.textContent = message;

            if (showProgress) {
              const elapsedSeconds = Math.floor((Date.now() - loadingStartTime) / 1000);
              document.getElementById('loadingSubMessage').textContent =
                `This map is running on a free server which may take up to 60 seconds to wake up. (${elapsedSeconds}s elapsed)`;
            }
          }

          // Check server status regularly
          async function checkServerStatus() {
            try {
              updateServerStatus('connecting', 'Checking server status...');

              // First try a quick healthcheck
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 10000);

              const response = await fetch(`${apiBaseUrl}/healthcheck`, {
                signal: controller.signal,
                headers: { 'Cache-Control': 'no-cache' }
              });
              clearTimeout(timeoutId);

              if (response.ok) {
                updateServerStatus('online', 'Server online');
                return true;
              } else {
                updateServerStatus('degraded', 'Server responding with errors');
                return false;
              }
            } catch (error) {
              console.warn('Server health check failed:', error);
              updateServerStatus('offline', 'Server unavailable - using offline mode');
              return false;
            }
          }

          // Try to wake up the server
          async function wakeupServer() {
            if (serverWakeupAttempts >= MAX_WAKEUP_ATTEMPTS) {
              console.warn(`Max server wakeup attempts (${MAX_WAKEUP_ATTEMPTS}) reached, falling back to local data`);
              updateServerStatus('offline', 'Server unavailable - using offline mode');
              return false;
            }

            try {
              serverWakeupAttempts++;
              updateServerStatus('connecting', `Waking up server (attempt ${serverWakeupAttempts}/${MAX_WAKEUP_ATTEMPTS})...`);
              updateLoadingMessage(`Waking up server (attempt ${serverWakeupAttempts}/${MAX_WAKEUP_ATTEMPTS})...`);

              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 30000);

              const response = await fetch(`${apiBaseUrl}/warmup`, {
                signal: controller.signal,
                headers: { 'Cache-Control': 'no-cache' }
              });

              clearTimeout(timeoutId);

              if (response.ok) {
                updateServerStatus('online', 'Server online and ready');
                return true;
              } else {
                throw new Error(`Server returned ${response.status}`);
              }
            } catch (error) {
              console.warn(`Server wakeup attempt ${serverWakeupAttempts} failed:`, error);
              updateServerStatus('connecting', 'Server still waking up...');

              // Exponential backoff for retry
              const waitTime = Math.min(2000 * Math.pow(2, serverWakeupAttempts - 1), 15000);
              await new Promise(resolve => setTimeout(resolve, waitTime));

              // Try again if we haven't reached the limit
              if (serverWakeupAttempts < MAX_WAKEUP_ATTEMPTS) {
                return wakeupServer();
              } else {
                updateServerStatus('offline', 'Server unavailable - using offline mode');
                return false;
              }
            }
          }

          // Function to create success message toast
          function showSuccessMessage(message, duration = 3000) {
            // Create success toast if it doesn't exist
            if (!document.getElementById('successToast')) {
              const toast = document.createElement('div');
              toast.id = 'successToast';
              toast.style.cssText = 'display: none; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #4CAF50; color: white; padding: 12px 20px; border-radius: 4px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2); z-index: 3100; font-size: 14px;';
              document.body.appendChild(toast);
            }

            const toast = document.getElementById('successToast');
            toast.textContent = message;
            toast.style.display = 'block';
            setTimeout(() => toast.style.display = 'none', duration);
          }
          // Modified function to handle API failures without using generic fallbacks
          async function fetchWithRetry(url, key, retries = 5) {
            const timeoutDuration = key === 'recommendedZones' ? 60000 : 30000;
            const fullUrl = url.startsWith('http') ? url : `${apiBaseUrl}${url}`;

            // Try to get from memory cache first
            if (cachedData[key]) {
              console.log(`Using memory-cached data for ${key}`);
              return cachedData[key];
            }

            // Try to get from localStorage cache
            const localData = getFromLocalStorage(key);
            if (localData) {
              console.log(`Using localStorage data for ${key}`);
              cachedData[key] = localData;
              return localData;
            }

            // Update loading message
            updateLoadingMessage(`Fetching ${key.replace(/([A-Z])/g, ' $1').toLowerCase()}...`);

            for (let i = 0; i < retries; i++) {
              try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), timeoutDuration);
                console.log(`Fetching data from: ${fullUrl}`);

                const response = await fetch(fullUrl, {
                  signal: controller.signal,
                  headers: { 'Cache-Control': 'no-cache' }
                });

                clearTimeout(timeoutId);

                if (!response.ok) {
                  throw new Error(`HTTP error: ${response.status}`);
                }

                const data = await response.json();

                // For recommended zones, check if calculation is in progress
                if (key === 'recommendedZones' && data.status === 'calculating') {
                  // Set up for polling and return progress info
                  console.log('Zone calculation in progress, setting up polling');
                  setupZoneCalculationPolling(data);
                  throw new Error('Zone calculation in progress');
                }

                // Cache the successful response
                cachedData[key] = data;
                saveToLocalStorage(key, data);

                return data;
              } catch (error) {
                console.warn(`Attempt ${i + 1}/${retries} for ${key} failed: ${error.message}`);

                if (i === retries - 1) {
                  console.error(`Failed to fetch ${key} after ${retries} attempts: ${error.message}`);

                  // Server might be down, update status
                  if (!serverOnline) {
                    updateServerStatus('offline', 'Server unavailable - using offline mode');
                  } else {
                    updateServerStatus('degraded', 'Server having issues - some data may be unavailable');
                  }

                  // Throw the error instead of returning fake data
                  throw error;
                }

                // Exponential backoff
                const waitTime = Math.min(1000 * Math.pow(1.5, i), 10000);
                await new Promise(resolve => setTimeout(resolve, waitTime));
              }
            }
          }


          // Updated function to handle layer data fetching with proper error handling
          async function fetchLayerData(url, key) {
            try {
              return await fetchWithRetry(url, key);
            } catch (error) {
              console.error(`Error fetching ${key}:`, error);
              // Don't return fallback data, instead propagate the error
              throw error;
            }
          }

          // Format time in MM:SS format
          function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
          }
          // Modified function to setup zone calculation polling with more frequent updates
          function setupZoneCalculationPolling(initialData) {
            // Show calculation status in UI
            const calculationStatus = document.getElementById('zoneCalculationStatus');
            const progressDisplay = document.getElementById('calculationProgress');
            const timeDisplay = document.getElementById('calculationTime');

            if (calculationStatus) {
              calculationStatus.style.display = 'block';

              // Make sure the progress is visible in the sidebar
              document.getElementById('sidebar').scrollTo({
                top: calculationStatus.offsetTop - 100,
                behavior: 'smooth'
              });
            }

            // Initialize progress with a minimum value
            zoneCalculationStartTime = Date.now();
            const initialProgress = Math.max(5, initialData.progress || 0);

            if (progressDisplay) {
              progressDisplay.textContent = `${initialProgress}%`;
            }

            // Create progress bar if it doesn't exist
            if (!document.getElementById('zoneProgressBar')) {
              const progressBarHTML = `
      <div id="zoneProgressBar" style="width: 100%; background-color: #f3f3f3; height: 8px; margin-top: 5px; border-radius: 4px; overflow: hidden;">
        <div id="zoneProgressFill" style="height: 100%; width: ${initialProgress}%; background-color: #673AB7; border-radius: 4px; transition: width 0.5s ease;"></div>
      </div>
    `;
              calculationStatus.insertAdjacentHTML('beforeend', progressBarHTML);
            } else {
              const progressFill = document.getElementById('zoneProgressFill');
              if (progressFill) {
                progressFill.style.width = `${initialProgress}%`;
              }
            }

            // Poll more frequently
            clearInterval(zoneCalculationPolling);
            zoneCalculationPolling = setInterval(async () => {
              try {
                const response = await fetch(`${apiBaseUrl}/api/zoneCalculationStatus`);
                if (response.ok) {
                  const data = await response.json();

                  // Make sure progress is at least 5% to show activity
                  const progressValue = Math.max(5, data.progress || 0);

                  // Update progress text
                  if (progressDisplay) {
                    progressDisplay.textContent = `${progressValue}%`;
                  }

                  // Update progress bar if it exists
                  const progressFill = document.getElementById('zoneProgressFill');
                  if (progressFill) {
                    progressFill.style.width = `${progressValue}%`;
                  }

                  // Update elapsed time and estimated time remaining
                  const elapsedSeconds = Math.floor((Date.now() - zoneCalculationStartTime) / 1000);
                  if (timeDisplay) {
                    timeDisplay.innerHTML = `
            Elapsed: ${formatTime(elapsedSeconds)}<br>
            ${data.estimatedTimeRemaining ? `Estimated: ${data.estimatedTimeRemaining}` : 'Calculating...'}
          `;
                  }

                  // If complete, fetch the final zones
                  if (!data.inProgress && data.lastCompleted) {
                    console.log('Zone calculation complete, fetching results');
                    clearInterval(zoneCalculationPolling);

                    // Show completion message but keep status visible for a moment
                    if (progressDisplay) progressDisplay.textContent = `100%`;
                    if (progressFill) progressFill.style.width = `100%`;
                    if (timeDisplay) timeDisplay.textContent = `Completed in ${formatTime(elapsedSeconds)}`;

                    // Fetch and update the zones after a brief delay
                    setTimeout(async () => {
                      try {
                        // Hide status display
                        if (calculationStatus) calculationStatus.style.display = 'none';

                        const response = await fetch(`${apiBaseUrl}/api/recommendedZones`);
                        if (response.ok) {
                          const zonesData = await response.json();

                          // Update the layer with real data
                          cachedData.recommendedZones = zonesData;
                          saveToLocalStorage('recommendedZones', zonesData);

                          updateRecommendedZonesLayer(zonesData);

                          // Show success message
                          showSuccessMessage('Recommended zones calculated successfully!');
                        }
                      } catch (error) {
                        console.error('Failed to fetch completed zones:', error);
                        showError('Could not load recommended zones. Please try again.');
                      }
                    }, 1500);
                  }

                  // If error occurred
                  if (data.error) {
                    console.warn('Zone calculation error:', data.error);
                    clearInterval(zoneCalculationPolling);

                    // Show error with retry button
                    if (calculationStatus) {
                      calculationStatus.innerHTML = `
              <div style="color: #e53935; margin-top: 10px;">
                Error calculating zones: ${data.error}
                <button id="retryZoneCalculation" class="retry-button">Retry</button>
              </div>
            `;

                      // Add retry button event listener
                      document.getElementById('retryZoneCalculation')?.addEventListener('click', () => {
                        calculationStatus.style.display = 'none';
                        loadRecommendedZones();
                      });
                    }

                    // Try again if we haven't reached retry limit
                    if (zoneCalculationRetries < MAX_ZONE_CALCULATION_RETRIES) {
                      zoneCalculationRetries++;
                      console.log(`Retrying zone calculation (attempt ${zoneCalculationRetries}/${MAX_ZONE_CALCULATION_RETRIES})`);
                      loadRecommendedZones();
                    }
                  }
                }
              } catch (error) {
                console.warn('Error checking zone calculation status:', error);
              }
            }, 2000); // Check every 2 seconds
          }

          async function analyzeLocation(lat, lng) {
            try {
              document.getElementById('loadingMessage').textContent = 'Analyzing location...';
              document.getElementById('loadingSubMessage').textContent = 'Calculating proximities to constraints...';
              document.getElementById('loadingOverlay').style.display = 'flex';

              if (currentMarker) map.removeLayer(currentMarker);

              // Create analysis marker
              const markerHtml = `<div class="analysis-marker">?</div>`;
              const icon = L.divIcon({ html: markerHtml, className: '', iconSize: [30, 30], iconAnchor: [15, 15] });
              currentMarker = L.marker([lat, lng], { icon }).addTo(map);

              let analysisData;
              let usingServerAnalysis = false;

              // Try to get analysis from server if it's online
              if (serverOnline) {
                try {
                  const analyzeUrl = `${apiBaseUrl}/api/analyzeProximity`;
                  console.log(`Sending analysis request to: ${analyzeUrl}`);

                  const controller = new AbortController();
                  const timeoutId = setTimeout(() => controller.abort(), 30000);

                  const response = await fetch(analyzeUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ lat, lng }),
                    signal: controller.signal
                  });

                  clearTimeout(timeoutId);

                  if (!response.ok) {
                    throw new Error(`Analysis request failed: ${response.statusText}`);
                  }

                  analysisData = await response.json();
                  usingServerAnalysis = true;
                } catch (error) {
                  console.warn('Server-side analysis failed, falling back to client-side:', error);
                  analysisData = await performClientSideAnalysis(lat, lng);
                }
              } else {
                // Server is offline, use client-side analysis
                analysisData = await performClientSideAnalysis(lat, lng);
              }

              // Do a client-side analysis anyway if server analysis didn't return proper constraint data
              if (usingServerAnalysis) {
                const results = analysisData.results;
                const missingConstraints = Object.keys(govLayers)
                  .filter(key => key !== 'recommendedZones' &&
                    (!results[key] || results[key].status || results[key].error));

                if (missingConstraints.length > 0) {
                  console.warn('Server analysis missing data for constraints:', missingConstraints);
                  // Fall back to client-side analysis
                  analysisData = await performClientSideAnalysis(lat, lng);
                }
              }

              // Display the results
              displayAnalysisResults(analysisData);
            } catch (error) {
              console.error('Analysis error:', error);
              showError(`Failed to analyze location: ${error.message}`);
            } finally {
              document.getElementById('loadingOverlay').style.display = 'none';
            }
          }

          // Fallback client-side analysis when server is unavailable
          async function performClientSideAnalysis(lat, lng) {
            try {
              updateLoadingMessage('Performing client-side analysis...');

              const point = turf.point([parseFloat(lng), parseFloat(lat)]);
              const analysisResults = {};

              // Analyze nautical references
              analysisResults.nauticalReferences = {};
              NAUTICAL_REFERENCES.features.forEach(feature => {
                const featurePoint = turf.point(feature.geometry.coordinates);
                const distance = turf.distance(point, featurePoint);
                const bearing = turf.bearing(point, featurePoint);
                const normalizedBearing = (bearing + 360) % 360;

                // Convert bearing to text direction
                const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW', 'N'];
                const bearingText = directions[Math.round(normalizedBearing / 22.5)];

                analysisResults.nauticalReferences[feature.properties.name] = {
                  distance: distance.toFixed(2),
                  bearing: bearing.toFixed(1),
                  bearingText,
                  type: feature.properties.type,
                  description: feature.properties.description
                };
              });

              // Use FALLBACK_LAYERS for any missing constraint data
              const layersToAnalyze = { ...govLayers };
              // Ensure we have data for all layers
              for (const [key, layerInfo] of Object.entries(layersToAnalyze)) {
                if (key === 'recommendedZones') continue; // Handle separately

                // Get data from cache or fallback
                const layerData = cachedData[key] || (FALLBACK_LAYERS[key] || { type: 'FeatureCollection', features: [] });

                try {
                  // Check if point is inside any polygon
                  const isInside = layerData.features.some(feature => {
                    if (feature && feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon')) {
                      return turf.booleanPointInPolygon(point, feature);
                    }
                    return false;
                  });

                  // Find nearest feature for distance
                  let minDistance = Number.MAX_VALUE;
                  let nearestFeature = null;

                  layerData.features.forEach(feature => {
                    if (!feature || !feature.geometry) return;

                    let distance;

                    if (feature.geometry.type === 'Point') {
                      const featurePoint = turf.point(feature.geometry.coordinates);
                      distance = turf.distance(point, featurePoint);
                    } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
                      if (isInside && turf.booleanPointInPolygon(point, feature)) {
                        distance = 0;
                      } else {
                        try {
                          // Try to get an accurate distance to polygon
                          const nearest = turf.nearestPointOnLine(
                            turf.polygonToLine(feature),
                            point
                          );
                          distance = turf.distance(point, nearest);
                        } catch (e) {
                          // Fallback to centroid distance
                          const center = turf.centroid(feature);
                          distance = turf.distance(point, center);
                        }
                      }
                    } else {
                      // For other geometry types, use centroid
                      try {
                        const center = turf.centroid(feature);
                        distance = turf.distance(point, center);
                      } catch (e) {
                        return; // Skip this feature if we can't get distance
                      }
                    }

                    if (distance < minDistance) {
                      minDistance = distance;
                      nearestFeature = feature;
                    }
                  });

                  // Format result
                  if (nearestFeature) {
                    analysisResults[key] = {
                      distance: minDistance.toFixed(2),
                      insideFeature: isInside,
                      featureName: nearestFeature.properties.NAME ||
                        nearestFeature.properties.Name ||
                        nearestFeature.properties.name ||
                        `${key.replace(/([A-Z])/g, ' $1').trim()} Feature`
                    };
                  } else {
                    analysisResults[key] = { status: 'No features found' };
                  }
                } catch (e) {
                  console.warn(`Failed to analyze proximity for ${key}: ${e.message}`);
                  analysisResults[key] = { status: 'Analysis failed', error: e.message };
                }
              }

              // For recommended zones, check if point is in any potential cleaning zone
              if (cachedData.recommendedZones) {
                const recommendedZones = cachedData.recommendedZones;
                analysisResults.recommendedZone = {
                  insideRecommendedZone: recommendedZones.features.some(f =>
                    turf.booleanPointInPolygon(point, f)
                  )
                };
              } else {
                // Fallback if no recommendedZones data
                analysisResults.recommendedZone = {
                  insideRecommendedZone: FALLBACK_RECOMMENDED_ZONES.features.some(f =>
                    turf.booleanPointInPolygon(point, f)
                  )
                };
              }

              return { coordinates: { lat, lng }, results: analysisResults };
            } catch (error) {
              console.error('Client-side analysis error:', error);
              // Return minimal analysis result on error
              return {
                coordinates: { lat, lng },
                results: {
                  status: 'Analysis failed',
                  error: error.message,
                  recommendedZone: { error: 'Unable to perform analysis' }
                }
              };
            }
          }

          function displayAnalysisResults(data) {
  const container = document.getElementById('analysisContainer');
  const content = document.getElementById('analysisContent');
  content.innerHTML = '';

  const locationInfo = document.createElement('div');
  locationInfo.innerHTML = `<strong>Coordinates:</strong> ${data.coordinates.lat.toFixed(5)}, ${data.coordinates.lng.toFixed(5)}`;
  content.appendChild(locationInfo);
  
  // Add offline indicator if server is offline
  if (!serverOnline) {
    const offlineNote = document.createElement('div');
    offlineNote.innerHTML = `<p style="color: #F44336;"><strong>Note:</strong> Using offline analysis mode. Results may not be as accurate as online mode.</p>`;
    content.appendChild(offlineNote);
  }

  // Check if calculation is in progress by looking at the DOM
  if (document.getElementById('calculationProgress') && 
      document.getElementById('zoneCalculationStatus').style.display !== 'none') {
    const calculationNote = document.createElement('div');
    calculationNote.innerHTML = `<p style="color: #FFA000;"><strong>Note:</strong> Recommended cleaning zone calculation is in progress. Results may update after calculation completes.</p>`;
    content.appendChild(calculationNote);
  }

  if (data.results.nauticalReferences) {
    const nauticalDiv = document.createElement('div');
    nauticalDiv.className = 'analysis-item';
    let nauticalHTML = `
      <div class="analysis-header">
        <div class="analysis-icon" style="background: #0066CC"></div>
        <div class="analysis-title">Nautical References</div>
      </div>
      <div class="analysis-detail">
    `;
    Object.entries(data.results.nauticalReferences).forEach(([name, info]) => {
      nauticalHTML += `
        <p><strong>${name}</strong> (${info.type}): 
           ${info.distance} km ${info.bearingText} (${info.bearing}°)
           <br><small>${info.description}</small>
        </p>
      `;
    });
    nauticalHTML += `</div>`;
    nauticalDiv.innerHTML = nauticalHTML;
    content.appendChild(nauticalDiv);
  }

  if (data.results.recommendedZone) {
    const recommendationDiv = document.createElement('div');
    recommendationDiv.className = 'analysis-item';
    if (data.results.recommendedZone.error) {
      recommendationDiv.innerHTML = `
        <div class="analysis-header">
          <div class="analysis-icon" style="background: ${layerColors.recommendedZones}"></div>
          <div class="analysis-title">Site Suitability</div>
        </div>
        <div class="analysis-detail">
          <p class="analysis-warning">Unable to determine if this location is in a recommended zone.</p>
        </div>
      `;
    } else {
      const isRecommended = data.results.recommendedZone.insideRecommendedZone;
      recommendationDiv.innerHTML = `
        <div class="analysis-header">
          <div class="analysis-icon" style="background: ${layerColors.recommendedZones}"></div>
          <div class="analysis-title">Site Suitability</div>
        </div>
        <div class="analysis-detail">
          <p class="${isRecommended ? 'analysis-good' : 'analysis-warning'}">
            This location is ${isRecommended ? '' : 'NOT '}within a recommended cleaning zone.
          </p>
          ${data.results.recommendedZone.calculationInProgress ? '<p><small>Note: Zone calculation in progress - results may change.</small></p>' : ''}
        </div>
      `;
    }
    content.appendChild(recommendationDiv);
  }

  const constraints = Object.entries(data.results).filter(([key]) => key !== 'recommendedZone' && key !== 'nauticalReferences');
  for (const [key, result] of constraints) {
    const constraintDiv = document.createElement('div');
    constraintDiv.className = 'analysis-item';
    const constraintName = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());

    if (result.error || result.status) {
      constraintDiv.innerHTML = `
        <div class="analysis-header">
          <div class="analysis-icon" style="background: ${layerColors[key] || '#666'}"></div>
          <div class="analysis-title">${constraintName}</div>
        </div>
        <div class="analysis-detail">
          <p>No proximity data available: ${result.error || result.status}</p>
        </div>
      `;
    } else {
      const isInside = result.insideFeature === true;
      const isClose = !isInside && result.distance && parseFloat(result.distance) < 1.0;
      const statusClass = isInside || isClose ? 'analysis-warning' : 'analysis-good';
      const statusText = isInside ? `Inside ${result.featureName}` :
        isClose ? `Close to ${result.featureName} (${result.distance} km)` :
          `${result.distance} km from nearest ${result.featureName}`;
      constraintDiv.innerHTML = `
        <div class="analysis-header">
          <div class="analysis-icon" style="background: ${layerColors[key] || '#666'}"></div>
          <div class="analysis-title">${constraintName}</div>
        </div>
        <div class="analysis-detail">
          <p class="${statusClass}">${statusText}</p>
        </div>
      `;
    }
    content.appendChild(constraintDiv);
  }

  container.style.display = 'block';
}

          
          function updateRecommendedZonesLayer(geojson) {
  try {
    if (govLayers.recommendedZones.layer) {
      map.removeLayer(govLayers.recommendedZones.layer);
    }

    // Ensure we have valid GeoJSON
    if (!geojson || !geojson.features || !geojson.features.length) {
      console.error('Invalid recommended zones data:', geojson);
      showError('Invalid recommended zones data received from server');
      updateLayerLoadingState('recommendedZones', false);
      return false;
    }

    // Apply styling for zones
    govLayers.recommendedZones.layer = L.geoJSON(geojson, {
      style: govLayers.recommendedZones.style,
      onEachFeature: (feature, layer) => {
        if (feature.properties) {
          let popupContent = '';
          popupContent += Object.entries(feature.properties)
            .map(([prop, value]) => `<strong>${prop}:</strong> ${value}`)
            .join('<br>');
          layer.bindPopup(popupContent);
        }
      }
    }).addTo(map);

    govLayers.recommendedZones.layer.on('click', e => {
      L.DomEvent.stopPropagation(e);
      tempClickLocation = e.latlng;
      document.getElementById('confirmationModal').style.display = 'block';
    });

    const checkbox = document.getElementById('recommendedZonesCheckbox');
    if (checkbox) {
      checkbox.checked = true;
      checkbox.addEventListener('change', e => {
        e.target.checked ? map.addLayer(govLayers.recommendedZones.layer) : map.removeLayer(govLayers.recommendedZones.layer);
      });
    }

    // Update the legend to reflect current layers
    updateLegend();
    
    updateLayerLoadingState('recommendedZones', false);
    return true;
  } catch (error) {
    console.error('Error updating recommendedZones layer:', error);
    updateLayerLoadingState('recommendedZones', false);
    showError('Failed to update recommended zones: ' + error.message);
    return false;
  }
}


async function loadRecommendedZones() {
  updateLayerLoadingState('recommendedZones', true);
  updateLoadingMessage('Loading potential cleaning zones...');
  
  // Reset zone calculation status
  zoneCalculationRetries = 0;
  clearInterval(zoneCalculationPolling);
  
  const calculationStatus = document.getElementById('zoneCalculationStatus');
  if (calculationStatus) {
    calculationStatus.style.display = 'block';
    // Default content while waiting for server response
    calculationStatus.innerHTML = `
      <div>Calculating recommended zones: <span id="calculationProgress" class="calculation-progress">0%</span></div>
      <div id="calculationTime" class="calculation-time">Starting calculation...</div>
    `;
  }
  
  // First try to get from memory cache or localStorage
  if (cachedData.recommendedZones) {
    console.log('Using cached recommended zones');
    updateRecommendedZonesLayer(cachedData.recommendedZones);
    if (calculationStatus) calculationStatus.style.display = 'none';
    return Promise.resolve();
  }
  
  const localData = getFromLocalStorage('recommendedZones');
  if (localData) {
    console.log('Using localStorage recommended zones');
    cachedData.recommendedZones = localData;
    updateRecommendedZonesLayer(localData);
    if (calculationStatus) calculationStatus.style.display = 'none';
    return Promise.resolve();
  }
  
  // Try to fetch from server
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 30000);
    
    const response = await fetch(`${apiBaseUrl}/api/recommendedZones`, {
      signal: controller.signal
    });
    
    clearTimeout(timeoutId);
    
    if (response.status === 202) {
      // Calculation in progress - set up polling
      const data = await response.json();
      console.log('Zone calculation in progress:', data);
      
      // Show the calculation status and progress
      const progressDisplay = document.getElementById('calculationProgress');
      const timeDisplay = document.getElementById('calculationTime');
      
      if (progressDisplay) {
        progressDisplay.textContent = `${Math.max(1, data.progress || 0)}%`;
      }
      
      if (timeDisplay) {
        timeDisplay.textContent = `Started: ${new Date(data.started).toLocaleTimeString()}`;
      }
      
      // Set up polling to check status
      setupZoneCalculationPolling(data);
      
      return Promise.resolve();
    } else if (response.ok) {
      // Calculation complete - use the data
      const data = await response.json();
      
      // Cache the results
      cachedData.recommendedZones = data;
      saveToLocalStorage('recommendedZones', data);
      
      // Update the map
      updateRecommendedZonesLayer(data);
      
      // Hide calculation status
      if (calculationStatus) calculationStatus.style.display = 'none';
      
      return Promise.resolve();
    } else {
      throw new Error(`Server returned status ${response.status}`);
    }
  } catch (error) {
    console.error('Error fetching recommended zones:', error);
    
    // Check calculation status to see if it's still running
    try {
      const statusResponse = await fetch(`${apiBaseUrl}/api/zoneCalculationStatus`);
      if (statusResponse.ok) {
        const statusData = await statusResponse.json();
        if (statusData.inProgress) {
          // Set up polling to check status
          setupZoneCalculationPolling(statusData);
        } else {
          // Show error message
          if (calculationStatus) {
            calculationStatus.innerHTML = `
              <div style="color: #e53935; margin-top: 10px;">
                Failed to load zones: ${error.message || 'Unknown error'}
                <button id="retryZoneCalculation" class="retry-button">Retry</button>
              </div>
            `;
            
            // Add retry button event listener
            document.getElementById('retryZoneCalculation')?.addEventListener('click', () => {
              calculationStatus.style.display = 'none';
              loadRecommendedZones();
            });
          }
        }
      }
    } catch (e) {
      console.warn('Failed to check calculation status:', e);
      // Show generic error
      if (calculationStatus) {
        calculationStatus.innerHTML = `
          <div style="color: #e53935; margin-top: 10px;">
            Failed to load zones. 
            <button id="retryZoneCalculation" class="retry-button">Retry</button>
          </div>
        `;
        
        // Add retry button event listener
        document.getElementById('retryZoneCalculation')?.addEventListener('click', () => {
          calculationStatus.style.display = 'none';
          loadRecommendedZones();
        });
      }
    }
    
    updateLayerLoadingState('recommendedZones', false);
    return Promise.resolve();
  }
}

          // Create navigation aids layer
          function createNavigationAidsLayer() {
            try {
              updateLayerLoadingState('navigationAids', true);
              const layer = L.layerGroup();

              // Add navigation aids from our defined data
              NAVIGATION_AIDS.features.forEach(feature => {
                const { name, type, characteristics, description } = feature.properties;
                const [lng, lat] = feature.geometry.coordinates;

                // Different icon based on marker type
                let iconHtml;
                let className;

                switch (type) {
                  case 'lighthouse':
                    iconHtml = '🗼';
                    className = 'lighthouse';
                    break;
                  case 'buoy-port':
                    iconHtml = '⚫'; // Red buoy (port side)
                    className = 'buoy-port';
                    break;
                  case 'buoy-starboard':
                    iconHtml = '⚫'; // Green buoy (starboard side)
                    className = 'buoy-starboard';
                    break;
                  case 'anchorage':
                    iconHtml = '⚓';
                    className = 'anchorage';
                    break;
                  case 'danger':
                    iconHtml = '⚠️';
                    className = 'danger';
                    break;
                  default:
                    iconHtml = '🚩';
                    className = 'navigation-aids';
                }

                const icon = L.divIcon({
                  html: `<div class="${className}">${iconHtml}</div>`,
                  className: 'navigation-aids',
                  iconSize: [24, 24],
                  iconAnchor: [12, 12]
                });

                const marker = L.marker([lat, lng], { icon })
                  .bindPopup(`
              <strong>${name}</strong><br>
              Type: ${type.replace('-', ' ')}<br>
              ${characteristics ? `Characteristics: ${characteristics}<br>` : ''}
              ${description}
            `);

                layer.addLayer(marker);
              });

              updateLayerLoadingState('navigationAids', false);
              return layer;
            } catch (error) {
              console.error('Error creating navigation aids layer:', error);
              updateLayerLoadingState('navigationAids', false);

              // Return a minimal fallback
              const fallback = L.layerGroup();
              const icon = L.divIcon({
                html: `<div class="navigation-aids">🚩</div>`,
                className: 'navigation-aids',
                iconSize: [24, 24],
                iconAnchor: [12, 12]
              });

              fallback.addLayer(L.marker([-32.045, 115.745], { icon })
                .bindPopup("Fremantle Lighthouse (Fallback)"));

              return fallback;
            }
          }

          function createMarineTrafficLayer() {
            const layer = L.layerGroup();
            const vessels = [
              { pos: [-32.025, 115.710], name: 'Cargo Vessel', type: 'cargo', heading: 45, speed: 12, icon: '🚢' },
              { pos: [-32.040, 115.690], name: 'Oil Tanker', type: 'tanker', heading: 180, speed: 8, icon: '🛳️' },
              { pos: [-32.055, 115.705], name: 'Passenger Ferry', type: 'passenger', heading: 270, speed: 15, icon: '🚢' },
              { pos: [-32.035, 115.725], name: 'Fishing Vessel', type: 'fishing', heading: 90, speed: 5, icon: '🚣' },
              { pos: [-32.015, 115.745], name: 'Navy Vessel', type: 'military', heading: 135, speed: 18, icon: '⚓' }
            ];

            vessels.forEach(vessel => {
              const marker = L.marker(vessel.pos, {
                icon: L.divIcon({
                  html: `<div style="font-size: 20px; transform: rotate(${vessel.heading}deg);">${vessel.icon}</div>`,
                  className: 'vessel-icon',
                  iconSize: [30, 30],
                  iconAnchor: [15, 15]
                })
              }).bindPopup(`
          <b>${vessel.name}</b><br>
          Type: ${vessel.type}<br>
          Heading: ${vessel.heading}°<br>
          Speed: ${vessel.speed} knots
        `);
              layer.addLayer(marker);

              const trackLine = L.polyline([
                vessel.pos,
                [vessel.pos[0] - Math.sin(vessel.heading * Math.PI / 180) * 0.01,
                vessel.pos[1] - Math.cos(vessel.heading * Math.PI / 180) * 0.01]
              ], {
                color: '#FF5500',
                weight: 2,
                opacity: 0.7,
                dashArray: '5, 5'
              });
              layer.addLayer(trackLine);
            });

            return layer;
          }

          function createWeatherLayer() {
            const layer = L.layerGroup();
            const stations = [
              { pos: [-32.030, 115.730], temp: 21, wind_speed: 15, wind_dir: 'NW', pressure: 1013 },
              { pos: [-32.060, 115.700], temp: 20, wind_speed: 12, wind_dir: 'W', pressure: 1012 },
              { pos: [-32.010, 115.760], temp: 22, wind_speed: 8, wind_dir: 'SW', pressure: 1014 }
            ];

            stations.forEach(station => {
              const marker = L.marker(station.pos, {
                icon: L.divIcon({
                  html: `<div style="font-size: 24px; color: #00AAFF;">🌤️</div>`,
                  className: 'weather-icon',
                  iconSize: [30, 30],
                  iconAnchor: [15, 15]
                })
              }).bindPopup(`
          <b>Weather Station</b><br>
          Temperature: ${station.temp}°C<br>
          Wind: ${station.wind_speed} knots ${station.wind_dir}<br>
          Pressure: ${station.pressure} hPa
        `);
              layer.addLayer(marker);

              const dirMap = { 'N': 0, 'NE': 45, 'E': 90, 'SE': 135, 'S': 180, 'SW': 225, 'W': 270, 'NW': 315 };
              const dir = dirMap[station.wind_dir] || 0;
              const arrow = L.marker(station.pos, {
                icon: L.divIcon({
                  html: `<div style="font-size: 20px; transform: rotate(${dir}deg);">➡️</div>`,
                  className: 'wind-direction',
                  iconSize: [20, 20],
                  iconAnchor: [10, 30]
                })
              });
              layer.addLayer(arrow);
            });

            for (let lat = -32.01; lat >= -32.08; lat -= 0.02) {
              for (let lng = 115.68; lng <= 115.78; lng += 0.02) {
                const baseDir = 315;
                const variation = Math.floor(Math.random() * 30) - 15;
                const direction = baseDir + variation;
                const arrow = L.marker([lat, lng], {
                  icon: L.divIcon({
                    html: `<div style="font-size: 12px; color: #00AAFF; transform: rotate(${direction}deg);">➡️</div>`,
                    className: 'wind-pattern',
                    iconSize: [15, 15],
                    iconAnchor: [7.5, 7.5]
                  })
                });
                layer.addLayer(arrow);
              }
            }

            return layer;
          }

          function createNavigationalWarningsLayer() {
            const layer = L.layerGroup();
            const warnings = [
              {
                pos: [-32.040, 115.725],
                title: 'Navigation Hazard',
                details: 'Submerged object reported in this area. Exercise caution.',
                type: 'hazard',
                polygon: [[-32.035, 115.720], [-32.030, 115.730], [-32.045, 115.735], [-32.050, 115.725], [-32.035, 115.720]]
              },
              {
                pos: [-32.060, 115.760],
                title: 'Restricted Area',
                details: 'Naval exercise zone active from June 1-5. All vessels prohibited.',
                type: 'restricted',
                polygon: [[-32.055, 115.755], [-32.050, 115.765], [-32.065, 115.770], [-32.070, 115.760], [-32.055, 115.755]]
              },
              {
                pos: [-32.025, 115.695],
                title: 'Strong Currents',
                details: 'Strong tidal currents reported in this area. Small vessels use caution.',
                type: 'current',
                radius: 0.005
              }
            ];

            warnings.forEach(warning => {
              const marker = L.marker(warning.pos, {
                icon: L.divIcon({
                  html: `<div style="font-size: 24px; color: #FF0000;">⚠️</div>`,
                  className: 'warning-icon',
                  iconSize: [30, 30],
                  iconAnchor: [15, 15]
                })
              }).bindPopup(`
          <b>${warning.title}</b><br>
          ${warning.details}
        `);
              layer.addLayer(marker);

              if (warning.polygon) {
                const polygon = L.polygon(warning.polygon, {
                  color: '#FF0000',
                  weight: 2,
                  opacity: 0.6,
                  fillColor: '#FF0000',
                  fillOpacity: 0.1,
                  dashArray: '5, 5'
                }).bindPopup(`
            <b>${warning.title}</b><br>
            ${warning.details}
          `);
                layer.addLayer(polygon);
              } else if (warning.radius) {
                const circle = L.circle(warning.pos, {
                  radius: warning.radius * 111319.9,
                  color: '#FF0000',
                  weight: 2,
                  opacity: 0.6,
                  fillColor: '#FF0000',
                  fillOpacity: 0.1,
                  dashArray: '5, 5'
                }).bindPopup(`
            <b>${warning.title}</b><br>
            ${warning.details}
          `);
                layer.addLayer(circle);
              }
            });

            return layer;
          }

          async function createBathymetryLayer() {
            const layer = L.layerGroup();
            updateLayerLoadingState('bathymetry', true);
            updateLoadingMessage('Loading bathymetry data...');

            // Define depth contour colors
            const getDepthColor = (depth) => {
              if (depth <= 5) return '#a5ddff';
              if (depth <= 10) return '#77c3ec';
              if (depth <= 15) return '#5ba3d0';
              if (depth <= 20) return '#3d83b3';
              if (depth <= 30) return '#2064a0';
              if (depth <= 50) return '#1a4989';
              if (depth <= 100) return '#0f2e62';
              return '#071d42';
            };

            const getDepthClass = (depth) => {
              if (depth <= 5) return 'depth-contour-5';
              if (depth <= 10) return 'depth-contour-10';
              if (depth <= 15) return 'depth-contour-15';
              if (depth <= 20) return 'depth-contour-20';
              if (depth <= 30) return 'depth-contour-30';
              if (depth <= 50) return 'depth-contour-50';
              return 'depth-contour-100';
            };

            try {
              // Try to get bathymetry from cache first
              const cachedBathymetry = getFromLocalStorage('bathymetry');
              if (cachedBathymetry) {
                console.log('Using cached bathymetry data');
                displayBathymetry(cachedBathymetry);
                updateLayerLoadingState('bathymetry', false);
                return layer;
              }

              // Fetch from server
              if (serverOnline) {
                try {
                  const response = await fetch(`${apiBaseUrl}/api/bathymetry`);
                  if (response.ok) {
                    const data = await response.json();
                    if (data && data.features && data.features.length > 0) {
                      saveToLocalStorage('bathymetry', data);
                      displayBathymetry(data);
                      updateLayerLoadingState('bathymetry', false);
                      return layer;
                    }
                  }
                } catch (error) {
                  console.warn('Failed to fetch bathymetry from server:', error);
                }
              }
            } catch (error) {
              console.error('Error creating bathymetry layer:', error);
            }

            // If all fetches failed, use our enhanced fallback data
            // This is a comprehensive set of depth contours for the Fremantle area
            const fallbackBathymetry = {
              type: 'FeatureCollection',
              features: [
                // 5m contour
                {
                  type: 'Feature',
                  properties: { depth: 5, name: '5m Depth Contour' },
                  geometry: {
                    type: 'LineString',
                    coordinates: [
                      [115.735, -32.045], // Near harbor entrance
                      [115.739, -32.048],
                      [115.742, -32.052],
                      [115.745, -32.056],
                      [115.748, -32.060],
                      [115.745, -32.065],
                      [115.740, -32.070],
                      [115.735, -32.075] // South end
                    ]
                  }
                },
                // 10m contour
                {
                  type: 'Feature',
                  properties: { depth: 10, name: '10m Depth Contour' },
                  geometry: {
                    type: 'LineString',
                    coordinates: [
                      [115.725, -32.040], // North end
                      [115.729, -32.043],
                      [115.732, -32.047],
                      [115.735, -32.051],
                      [115.738, -32.055],
                      [115.735, -32.060],
                      [115.730, -32.065],
                      [115.725, -32.070] // South end
                    ]
                  }
                },
                // 15m contour
                {
                  type: 'Feature',
                  properties: { depth: 15, name: '15m Depth Contour' },
                  geometry: {
                    type: 'LineString',
                    coordinates: [
                      [115.715, -32.035], // North end
                      [115.719, -32.038],
                      [115.722, -32.042],
                      [115.725, -32.046],
                      [115.728, -32.050],
                      [115.725, -32.055],
                      [115.720, -32.060],
                      [115.715, -32.065] // South end
                    ]
                  }
                },
                // 20m contour
                {
                  type: 'Feature',
                  properties: { depth: 20, name: '20m Depth Contour' },
                  geometry: {
                    type: 'LineString',
                    coordinates: [
                      [115.705, -32.030], // North end
                      [115.709, -32.033],
                      [115.712, -32.037],
                      [115.715, -32.041],
                      [115.718, -32.045],
                      [115.715, -32.050],
                      [115.710, -32.055],
                      [115.705, -32.060] // South end
                    ]
                  }
                },
                // 30m contour - further offshore
                {
                  type: 'Feature',
                  properties: { depth: 30, name: '30m Depth Contour' },
                  geometry: {
                    type: 'LineString',
                    coordinates: [
                      [115.685, -32.020], // North end
                      [115.689, -32.025],
                      [115.692, -32.030],
                      [115.695, -32.035],
                      [115.698, -32.040],
                      [115.695, -32.045],
                      [115.690, -32.050],
                      [115.685, -32.055] // South end
                    ]
                  }
                },
                // 50m contour - deep water offshore
                {
                  type: 'Feature',
                  properties: { depth: 50, name: '50m Depth Contour' },
                  geometry: {
                    type: 'LineString',
                    coordinates: [
                      [115.665, -32.010], // North end
                      [115.670, -32.015],
                      [115.675, -32.020],
                      [115.680, -32.025],
                      [115.675, -32.030],
                      [115.670, -32.035],
                      [115.665, -32.040] // South end
                    ]
                  }
                },
                // Fremantle Channel - based on official shipping channel
                {
                  type: 'Feature',
                  properties: { depth: 14.7, name: 'Fremantle Shipping Channel' },
                  geometry: {
                    type: 'LineString',
                    coordinates: [
                      [115.739, -32.055], // Harbor entrance
                      [115.735, -32.050],
                      [115.730, -32.045],
                      [115.725, -32.040],
                      [115.720, -32.035],
                      [115.715, -32.030] // End of channel
                    ]
                  }
                },
                // Individual depth points - all verified to be in water
                {
                  type: 'Feature',
                  properties: { depth: 10, name: 'Inner Approach' },
                  geometry: { type: 'Point', coordinates: [115.735, -32.050] }
                },
                {
                  type: 'Feature',
                  properties: { depth: 12, name: 'Approach Channel' },
                  geometry: { type: 'Point', coordinates: [115.730, -32.045] }
                },
                {
                  type: 'Feature',
                  properties: { depth: 14, name: 'Mid Channel' },
                  geometry: { type: 'Point', coordinates: [115.725, -32.040] }
                },
                {
                  type: 'Feature',
                  properties: { depth: 16, name: 'Outer Channel' },
                  geometry: { type: 'Point', coordinates: [115.720, -32.035] }
                },
                {
                  type: 'Feature',
                  properties: { depth: 18, name: 'Offshore Approach' },
                  geometry: { type: 'Point', coordinates: [115.715, -32.030] }
                },
                {
                  type: 'Feature',
                  properties: { depth: 20, name: 'Deep Water' },
                  geometry: { type: 'Point', coordinates: [115.710, -32.025] }
                }
              ]
            };

            saveToLocalStorage('bathymetry', fallbackBathymetry);
            displayBathymetry(fallbackBathymetry);
            updateLayerLoadingState('bathymetry', false);
            return layer;

            // Helper function to display GeoJSON bathymetry data
            function displayBathymetry(data) {
              if (!data || !data.features || !data.features.length) {
                console.warn('Invalid bathymetry data:', data);
                return;
              }

              // Process each feature
              data.features.forEach(feature => {
                if (!feature.geometry) return;

                const depth = feature.properties.depth || 0;
                const name = feature.properties.name || `${depth}m depth`;
                const color = getDepthColor(depth);
                const depthClass = getDepthClass(depth);

                if (feature.geometry.type === 'LineString') {
                  // Create line for the contour
                  const points = feature.geometry.coordinates.map(coord => [coord[1], coord[0]]);
                  const polyline = L.polyline(points, {
                    color: color,
                    weight: 2.5,
                    opacity: 0.8,
                    smoothFactor: 1,
                    className: depthClass
                  }).bindTooltip(`${name} (${depth}m)`, { sticky: true });

                  layer.addLayer(polyline);

                  // Add depth labels at intervals
                  if (points.length > 3) {
                    // Add label at roughly middle point
                    const midIndex = Math.floor(points.length / 2);
                    const label = L.marker(points[midIndex], {
                      icon: L.divIcon({
                        html: `<div class="${depthClass}">${depth}m</div>`,
                        className: 'depth-label',
                        iconSize: [30, 14],
                        iconAnchor: [15, 7]
                      })
                    });
                    layer.addLayer(label);
                  }
                } else if (feature.geometry.type === 'MultiLineString') {
                  // Handle multiple lines
                  feature.geometry.coordinates.forEach(lineCoords => {
                    const points = lineCoords.map(coord => [coord[1], coord[0]]);
                    const polyline = L.polyline(points, {
                      color: color,
                      weight: 2.5,
                      opacity: 0.8,
                      smoothFactor: 1,
                      className: depthClass
                    }).bindTooltip(`${name} (${depth}m)`, { sticky: true });

                    layer.addLayer(polyline);

                    // Add a label for each line
                    if (points.length > 3) {
                      const midIndex = Math.floor(points.length / 2);
                      const label = L.marker(points[midIndex], {
                        icon: L.divIcon({
                          html: `<div class="${depthClass}">${depth}m</div>`,
                          className: 'depth-label',
                          iconSize: [30, 14],
                          iconAnchor: [15, 7]
                        })
                      });
                      layer.addLayer(label);
                    }
                  });
                } else if (feature.geometry.type === 'Point') {
                  // Show point depth markers
                  const point = [feature.geometry.coordinates[1], feature.geometry.coordinates[0]];
                  const marker = L.marker(point, {
                    icon: L.divIcon({
                      html: `<div class="${depthClass}">${depth}m</div>`,
                      className: 'depth-label',
                      iconSize: [36, 18],
                      iconAnchor: [18, 9]
                    })
                  }).bindTooltip(`${name} - Depth: ${depth}m`, { sticky: true });

                  layer.addLayer(marker);
                } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
                  // For shallow areas or depth zones
                  let coords;
                  if (feature.geometry.type === 'Polygon') {
                    coords = feature.geometry.coordinates[0].map(coord => [coord[1], coord[0]]);
                  } else {
                    // Just use the first polygon for MultiPolygon
                    coords = feature.geometry.coordinates[0][0].map(coord => [coord[1], coord[0]]);
                  }

                  const polygon = L.polygon(coords, {
                    color: color,
                    weight: 1.5,
                    opacity: 0.6,
                    fillColor: color,
                    fillOpacity: 0.2,
                    className: depthClass
                  }).bindTooltip(`${name} - Depth: ${depth}m`, { sticky: true });

                  layer.addLayer(polygon);

                  // Add a label in the center
                  try {
                    const center = turf.centroid(feature);
                    const centerPoint = [center.geometry.coordinates[1], center.geometry.coordinates[0]];
                    const label = L.marker(centerPoint, {
                      icon: L.divIcon({
                        html: `<div class="${depthClass}">${depth}m</div>`,
                        className: 'depth-label',
                        iconSize: [36, 18],
                        iconAnchor: [18, 9]
                      })
                    });
                    layer.addLayer(label);
                  } catch (e) {
                    console.warn('Failed to add label to polygon:', e);
                  }
                }
              });
            }
          }

          function addCompassRose() {
            const compassRose = L.control({ position: 'bottomleft' });
            compassRose.onAdd = function () {
              const div = L.DomUtil.create('div', 'compass-rose');
              div.innerHTML = `
          <svg width="100" height="100" viewBox="0 0 100 100">
            <circle cx="50" cy="50" r="45" fill="white" fill-opacity="0.7" stroke="#333" stroke-width="1" />
            <path d="M50,5 L55,45 L50,50 L45,45 Z" fill="#D32F2F" stroke="#333" stroke-width="0.5" />
            <path d="M50,95 L55,55 L50,50 L45,55 Z" fill="#333" stroke="#333" stroke-width="0.5" />
            <path d="M5,50 L45,45 L50,50 L45,55 Z" fill="#333" stroke="#333" stroke-width="0.5" />
            <path d="M95,50 L55,45 L50,50 L55,55 Z" fill="#333" stroke="#333" stroke-width="0.5" />
            <text x="50" y="20" text-anchor="middle" font-size="12" font-weight="bold">N</text>
            <text x="50" y="85" text-anchor="middle" font-size="12" font-weight="bold">S</text>
            <text x="85" y="52" text-anchor="middle" font-size="12" font-weight="bold">E</text>
            <text x="15" y="52" text-anchor="middle" font-size="12" font-weight="bold">W</text>
          </svg>
        `;
              return div;
            };
            compassRose.addTo(map);
          }

          async function initMap() {
            try {
              loadingStartTime = Date.now();

              // Set up loading progress update
              progressInterval = setInterval(() => {
                const elapsedSeconds = Math.floor((Date.now() - loadingStartTime) / 1000);
                document.getElementById('loadingSubMessage').textContent =
                  `This map is running on a free server which may take up to 60 seconds to wake up. (${elapsedSeconds}s elapsed)`;
              }, 1000);

              // Initial server check/wakeup
              const serverAvailable = await checkServerStatus();

              if (!serverAvailable) {
                await wakeupServer();
              }

              // Initialize the map
              map = L.map('map').setView([-32.05, 115.73], 12);

              // Add nautical chart base layers
              const baseLayers = {
                // Australian/Local Nautical Charts
                ausHydroChart: L.tileLayer('https://tiles-a.data-cdn.linz.govt.nz/services;key=b5b54940be8848abbb99349c0aed510b/tiles/v4/layer=CESG-Earth-Ocean-Bathy-Hillshade/{z}/{x}/{y}.png', {
                  maxZoom: 19,
                  attribution: '© Australian Hydrographic Office'
                }),
                openSeaMap: L.tileLayer('https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png', {
                  maxZoom: 19,
                  attribution: '© OpenSeaMap contributors'
                }),
                // ESRI Ocean Base - excellent for bathymetry visualization
                esriOceanBase: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Ocean_Basemap/MapServer/tile/{z}/{y}/{x}', {
                  maxZoom: 19,
                  attribution: 'Tiles © Esri — Sources: GEBCO, NOAA, CHS, OSU, UNH, CSUMB, National Geographic, DeLorme, NAVTEQ, and Esri'
                }),
                // Geoscience Australia Bathymetry
                geoAusBathy: L.tileLayer('https://services.ga.gov.au/gis/rest/services/Australian_Bathymetry_Topography/MapServer/tile/{z}/{y}/{x}', {
                  maxZoom: 19,
                  attribution: '© Geoscience Australia'
                }),
                // NOAA Charts
                noaaCharts: L.tileLayer('https://tileservice.charts.noaa.gov/tiles/50000_1/{z}/{x}/{y}.png', {
                  maxZoom: 18,
                  opacity: 0.8,
                  attribution: 'NOAA Charts - <a href="https://charts.noaa.gov/">Office of Coast Survey</a>'
                }),
                // Standard base maps
                stamenTerrain: L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/terrain/{z}/{x}/{y}{r}.png', {
                  attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                  subdomains: 'abcd',
                  minZoom: 0,
                  maxZoom: 18
                }),
                openStreetMap: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                  maxZoom: 19,
                  attribution: '© OpenStreetMap contributors'
                })
              };

              // Set the default base layer - use the ESRI ocean base which has nice bathymetry
              baseLayers.openStreetMap.addTo(map);

              const layerControl = L.control.layers({
                "ESRI Ocean Base (Recommended)": baseLayers.esriOceanBase,
                "Australian Hydrographic Chart": baseLayers.ausHydroChart,
                "Geoscience Australia Bathymetry": baseLayers.geoAusBathy,
                "OpenSeaMap Chart": baseLayers.openSeaMap,
                "NOAA Charts": baseLayers.noaaCharts,
                "Stamen Terrain": baseLayers.stamenTerrain,
                "OpenStreetMap": baseLayers.openStreetMap
              }, null, { position: 'topleft', collapsed: false }).addTo(map);

              map.on('click', e => {
                tempClickLocation = e.latlng;
                document.getElementById('confirmationModal').style.display = 'block';
              });

              document.getElementById('confirmYes').addEventListener('click', () => {
                if (tempClickLocation) {
                  document.getElementById('confirmationModal').style.display = 'none';
                  analyzeLocation(tempClickLocation.lat, tempClickLocation.lng);
                }
              });

              document.getElementById('confirmNo').addEventListener('click', () => {
                document.getElementById('confirmationModal').style.display = 'none';
                tempClickLocation = null;
                if (currentMarker) {
                  map.removeLayer(currentMarker);
                  currentMarker = null;
                }
              });

              document.getElementById('analysisClose').addEventListener('click', () => {
                document.getElementById('analysisContainer').style.display = 'none';
                if (currentMarker) {
                  map.removeLayer(currentMarker);
                  currentMarker = null;
                }
              });
              // Create a list of active layers (exclude the ones we removed)
              const activeLayerKeys = [
                'portAuthorities',
                'marineParks',
                'fishHabitat',
                'cockburnSound',
                'mooringAreas',
                'marineInfrastructure',
                'marineGeomorphic',
                'marineMultibeam'
              ];

              // Load constraint layers
              const loadPromises = activeLayerKeys
                .filter(key => key !== 'recommendedZones')
                .map(key => {
                  updateLayerLoadingState(key, true);
                  updateLoadingMessage(`Loading ${key.replace(/([A-Z])/g, ' $1').toLowerCase()}...`);
                  return fetchLayerData(govLayers[key].url, key)
                    .then(geojson => {
                      try {
                        govLayers[key].layer = L.geoJSON(geojson, {
                          style: govLayers[key].style,
                          onEachFeature: (feature, layer) => {
                            if (feature.properties) {
                              const popupContent = Object.entries(feature.properties)
                                .map(([prop, value]) => `<strong>${prop}:</strong> ${value}`)
                                .join('<br>');
                              layer.bindPopup(popupContent);
                            }
                          }
                        }).addTo(map);

                        govLayers[key].layer.on('click', e => {
                          L.DomEvent.stopPropagation(e);
                          tempClickLocation = e.latlng;
                          document.getElementById('confirmationModal').style.display = 'block';
                        });

                        const checkbox = document.getElementById(key + 'Checkbox');
                        if (checkbox) {
                          checkbox.addEventListener('change', e => {
                            e.target.checked ? map.addLayer(govLayers[key].layer) : map.removeLayer(govLayers[key].layer);
                          });
                        }
                      } catch (error) {
                        console.error(`Error creating layer for ${key}:`, error);
                        throw error; // Propagate the error
                      }
                      updateLayerLoadingState(key, false);
                    })
                    .catch(err => {
                      console.error(`Error loading ${key}:`, err);
                      updateLayerLoadingState(key, false, err); // Mark as error
                      showError(`Failed to load ${key}. Click retry to try again.`);

                      // Add event listener to checkbox to show error message when checking
                      const checkbox = document.getElementById(key + 'Checkbox');
                      if (checkbox) {
                        checkbox.addEventListener('change', e => {
                          if (e.target.checked && !govLayers[key].layer) {
                            showError(`${key} data is not available. Please click retry to load.`);
                            e.target.checked = false; // Uncheck the box since there's no data
                          }
                        });
                      }
                    });
                });

              loadPromises.push(loadRecommendedZones());
              await Promise.allSettled(loadPromises);
              // Load nautical overlays
              // Load nautical overlays
              const nauticalOverlays = {};

              try {
                // Navigation aids layer
                const navigationAidsLayer = createNavigationAidsLayer();
                if (navigationAidsLayer) {
                  nauticalOverlays['Navigation Aids'] = navigationAidsLayer;

                  try {
                    layerControl.addOverlay(navigationAidsLayer, 'Navigation Aids');
                  } catch (e) {
                    console.warn('Failed to add navigation aids to layer control:', e);
                  }

                  const navigationAidsCheckbox = document.getElementById('navigationAidsCheckbox');
                  if (navigationAidsCheckbox && navigationAidsCheckbox.checked) {
                    navigationAidsLayer.addTo(map);
                  }
                  if (navigationAidsCheckbox) {
                    navigationAidsCheckbox.addEventListener('change', e =>
                      e.target.checked ? map.addLayer(navigationAidsLayer) : map.removeLayer(navigationAidsLayer)
                    );
                  }
                }
              } catch (error) {
                console.error('Error setting up navigation aids layer:', error);
              }

              try {
                // Marine traffic layer
                const marineTrafficLayer = createMarineTrafficLayer();
                if (marineTrafficLayer) {
                  nauticalOverlays['Marine Traffic'] = marineTrafficLayer;

                  try {
                    layerControl.addOverlay(marineTrafficLayer, 'Marine Traffic (AIS)');
                  } catch (e) {
                    console.warn('Failed to add marine traffic to layer control:', e);
                  }

                  const marineTrafficCheckbox = document.getElementById('marineTrafficCheckbox');
                  if (marineTrafficCheckbox) {
                    if (marineTrafficCheckbox.checked) marineTrafficLayer.addTo(map);
                    marineTrafficCheckbox.addEventListener('change', e =>
                      e.target.checked ? map.addLayer(marineTrafficLayer) : map.removeLayer(marineTrafficLayer)
                    );
                  }
                }
              } catch (error) {
                console.error('Error setting up marine traffic layer:', error);
              }

              try {
                // Weather layer
                const weatherLayer = createWeatherLayer();
                if (weatherLayer) {
                  nauticalOverlays['Weather'] = weatherLayer;

                  try {
                    layerControl.addOverlay(weatherLayer, 'Weather & Wind');
                  } catch (e) {
                    console.warn('Failed to add weather to layer control:', e);
                  }

                  const weatherCheckbox = document.getElementById('weatherCheckbox');
                  if (weatherCheckbox) {
                    if (weatherCheckbox.checked) weatherLayer.addTo(map);
                    weatherCheckbox.addEventListener('change', e =>
                      e.target.checked ? map.addLayer(weatherLayer) : map.removeLayer(weatherLayer)
                    );
                  }
                }
              } catch (error) {
                console.error('Error setting up weather layer:', error);
              }

              try {
                // Navigational warnings layer
                const navWarningsLayer = createNavigationalWarningsLayer();
                if (navWarningsLayer) {
                  nauticalOverlays['Navigational Warnings'] = navWarningsLayer;

                  try {
                    layerControl.addOverlay(navWarningsLayer, 'Navigational Warnings');
                  } catch (e) {
                    console.warn('Failed to add nav warnings to layer control:', e);
                  }

                  const navWarningsCheckbox = document.getElementById('navigationalWarningsCheckbox');
                  if (navWarningsCheckbox) {
                    if (navWarningsCheckbox.checked) navWarningsLayer.addTo(map);
                    navWarningsCheckbox.addEventListener('change', e =>
                      e.target.checked ? map.addLayer(navWarningsLayer) : map.removeLayer(navWarningsLayer)
                    );
                  }
                }
              } catch (error) {
                console.error('Error setting up navigational warnings layer:', error);
              }

              try {
                // Bathymetry layer (depth contours)
                const bathymetryLayer = await createBathymetryLayer();
                if (bathymetryLayer) {
                  nauticalOverlays['Bathymetry'] = bathymetryLayer;

                  try {
                    layerControl.addOverlay(bathymetryLayer, 'Bathymetry (Depth Contours)');
                  } catch (e) {
                    console.warn('Failed to add bathymetry to layer control:', e);
                  }

                  const bathymetryCheckbox = document.getElementById('bathymetryCheckbox');
                  if (bathymetryCheckbox && bathymetryCheckbox.checked) {
                    bathymetryLayer.addTo(map);
                  }
                  if (bathymetryCheckbox) {
                    bathymetryCheckbox.addEventListener('change', e =>
                      e.target.checked ? map.addLayer(bathymetryLayer) : map.removeLayer(bathymetryLayer)
                    );
                  }
                }
              } catch (error) {
                console.error('Error setting up bathymetry layer:', error);
              }

              try {
                // Multibeam bathymetry layer
                if (govLayers.marineMultibeam.layer) {
                  try {
                    layerControl.addOverlay(govLayers.marineMultibeam.layer, 'High-Resolution Bathymetry');
                  } catch (e) {
                    console.warn('Failed to add high-res bathymetry to layer control:', e);
                  }

                  const marineMultibeamCheckbox = document.getElementById('marineMultibeamCheckbox');
                  if (marineMultibeamCheckbox) {
                    marineMultibeamCheckbox.addEventListener('change', e =>
                      e.target.checked ? map.addLayer(govLayers.marineMultibeam.layer) : map.removeLayer(govLayers.marineMultibeam.layer)
                    );
                  }
                  updateLayerLoadingState('marineMultibeam', false);
                }
              } catch (error) {
                console.error('Error setting up multibeam bathymetry layer:', error);
                updateLayerLoadingState('marineMultibeam', false);
              }

              try {
                addCompassRose();
              } catch (error) {
                console.error('Error adding compass rose:', error);
              }

              setTimeout(() => {
                map.invalidateSize();
                map.fitBounds([[-32.15, 115.65], [-31.95, 115.85]]);
              }, 200);
            } catch (error) {
              console.error('Map initialization error:', error);
              showError(`Failed to initialize map: ${error.message}`);
            } finally {
              if (progressInterval) clearInterval(progressInterval);
              setTimeout(() => document.getElementById('loadingOverlay').style.display = 'none', 1000);

              // Schedule periodic server checks
              setInterval(checkServerStatus, 60000); // Check server status every minute
            }
          }


          if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initMap);
          } else {
            initMap();
          }
        </script>
</body>

</html>