<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Hull Cleaning Constraints Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" crossorigin="" />
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: Arial, sans-serif;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    #sidebar {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1000;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      max-width: 350px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .constraint-group {
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #eee;
    }

    .constraint-group h4 {
      margin: 5px 0;
      color: #333;
    }

    .layer-control {
      margin: 5px 0;
    }

    .layer-control label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      font-size: 0.9em;
    }

    .layer-control-loading {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .layer-control-loading:after {
      content: " (loading...)";
      font-style: italic;
      color: #666;
    }

    .legend {
      margin-top: 20px;
      padding-top: 10px;
      border-top: 2px solid #ccc;
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin: 5px 0;
      font-size: 0.85em;
    }

    .legend-color {
      width: 20px;
      height: 20px;
      margin-right: 8px;
      border: 1px solid #999;
      border-radius: 3px;
    }

    .info-text {
      font-size: 0.9em;
      color: #666;
      margin: 10px 0;
      padding: 10px;
      background: #f5f5f5;
      border-radius: 4px;
    }

    #loadingOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 3000;
      font-family: sans-serif;
      text-align: center;
      padding: 20px;
    }

    .spinner {
      border: 8px solid #f3f3f3;
      border-top: 8px solid #673AB7;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    #loadingMessage {
      font-size: 1.1em;
      color: #333;
    }

    #analysisContainer {
      display: none;
      position: fixed;
      left: 20px;
      bottom: 20px;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      max-width: 400px;
      max-height: 60vh;
      overflow-y: auto;
      z-index: 1500;
    }

    #analysisClose {
      position: absolute;
      top: 10px;
      right: 10px;
      cursor: pointer;
      font-size: 18px;
      color: #666;
    }

    #analysisContent {
      margin-top: 10px;
    }

    .analysis-item {
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid #eee;
    }

    .analysis-item:last-child {
      border-bottom: none;
    }

    .analysis-header {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }

    .analysis-icon {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .analysis-title {
      font-weight: bold;
      font-size: 0.95em;
    }

    .analysis-detail {
      margin-left: 20px;
      font-size: 0.85em;
      color: #555;
    }

    .analysis-warning {
      color: #e53935;
      font-weight: bold;
    }

    .analysis-good {
      color: #43a047;
      font-weight: bold;
    }

    .nautical-reference {
      font-size: 0.9em;
      background-color: #f0f8ff;
      padding: 6px;
      margin-bottom: 6px;
      border-left: 3px solid #0066CC;
    }

    #errorToast {
      display: none;
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #f44336;
      color: white;
      padding: 12px 20px;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      z-index: 3100;
      font-size: 14px;
    }

    .analysis-marker {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: rgba(103, 58, 183, 0.8);
      color: white;
      font-weight: bold;
      border: 2px solid white;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    }

    .compass-rose,
    .vessel-icon,
    .weather-icon,
    .warning-icon,
    .depth-label,
    .sea-mark-icon {
      background: transparent;
      border: none;
    }

    .depth-label {
      font-weight: bold;
      text-shadow: 0px 0px 2px white;
    }

    .sea-mark-icon {
      filter: drop-shadow(0px 0px 1px white);
    }
  </style>
</head>

<body>
  <div id="loadingOverlay">
    <div class="spinner"></div>
    <div id="loadingMessage">Loading marine data...</div>
  </div>
  <div id="errorToast"></div>
  <div id="analysisContainer">
    <span id="analysisClose">√ó</span>
    <h3>Location Analysis</h3>
    <div id="analysisContent"></div>
  </div>
  <div id="confirmationModal"
    style="display: none; position: fixed; z-index: 2500; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5);">
    <div
      style="background-color: white; margin: 15% auto; padding: 20px; border-radius: 8px; width: 300px; text-align: center; box-shadow: 0 4px 8px rgba(0,0,0,0.2);">
      <h4 style="margin-top: 0;">Location Analysis</h4>
      <p>Would you like to generate a report for this location?</p>
      <div style="display: flex; justify-content: center; gap: 10px;">
        <button id="confirmYes"
          style="padding: 8px 16px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Yes</button>
        <button id="confirmNo"
          style="padding: 8px 16px; background-color: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">No</button>
      </div>
    </div>
  </div>
  <div id="map"></div>
  <div id="sidebar">
    <h3>Hull Cleaning Constraints</h3>
    <div class="info-text">
      To select potential cleaning sites, ensure the location:
      <ul>
        <li>Is outside Fremantle Port limits</li>
        <li>Has minimal proximity to sensitive receptors (marine parks, fish habitat, Cockburn Sound protection, etc.)
        </li>
        <li>Offers sufficient water flow for safe dispersion of residuals</li>
      </ul>
      Areas shown in the "Potential Cleaning Zones" layer represent parts of the study area that do not intersect with
      restricted zones.
      <p><em>Click anywhere on the map to analyze a potential cleaning location.</em></p>
    </div>
    <div class="constraint-group">
      <h4>Jurisdictional</h4>
      <div class="layer-control layer-control-loading">
        <label><input type="checkbox" id="portAuthoritiesCheckbox" checked> Port Authority Areas</label>
      </div>
    </div>
    <div class="constraint-group">
      <h4>Environmental Protection</h4>
      <div class="layer-control layer-control-loading">
        <label><input type="checkbox" id="marineParksCheckbox" checked> Marine Parks & Reserves</label>
      </div>
      <div class="layer-control layer-control-loading">
        <label><input type="checkbox" id="fishHabitatCheckbox" checked> Fish Habitat Protection Areas</label>
      </div>
      <div class="layer-control layer-control-loading">
        <label><input type="checkbox" id="cockburnSoundCheckbox" checked> Cockburn Sound Protection Area</label>
      </div>
    </div>
    <div class="constraint-group">
      <h4>Infrastructure</h4>
      <div class="layer-control layer-control-loading">
        <label><input type="checkbox" id="mooringAreasCheckbox" checked> Mooring Control Areas</label>
      </div>
      <div class="layer-control layer-control-loading">
        <label><input type="checkbox" id="marineInfrastructureCheckbox" checked> Marine Infrastructure</label>
      </div>
    </div>
    <div class="constraint-group">
      <h4>Recommended Cleaning Zones</h4>
      <div class="layer-control layer-control-loading">
        <label><input type="checkbox" id="recommendedZonesCheckbox" checked> Potential Cleaning Zones</label>
      </div>
    </div>
    <div class="constraint-group">
      <h4>Nautical Overlays</h4>
      <div class="layer-control layer-control-loading">
        <label><input type="checkbox" id="seaMarksCheckbox" checked> Sea Marks</label>
      </div>
      <div class="layer-control">
        <label><input type="checkbox" id="marineTrafficCheckbox"> Marine Traffic (AIS)</label>
      </div>
      <div class="layer-control">
        <label><input type="checkbox" id="weatherCheckbox"> Weather & Wind</label>
      </div>
      <div class="layer-control">
        <label><input type="checkbox" id="navigationalWarningsCheckbox"> Navigational Warnings</label>
      </div>
      <div class="layer-control">
        <label><input type="checkbox" id="bathymetryCheckbox" checked> Bathymetry (Depth Contours)</label>
      </div>
    </div>
    <div class="legend">
      <h4>Legend</h4>
      <div class="legend-item">
        <div class="legend-color" style="background: #FF4081"></div> Port Authority Areas
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #4CAF50"></div> Marine Parks & Reserves
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #FF9800"></div> Fish Habitat Areas
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #2196F3"></div> Cockburn Sound
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #9C27B0"></div> Mooring Areas
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #795548"></div> Marine Infrastructure
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #673AB7"></div> Potential Cleaning Zones
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #000"></div> Sea Marks (Nautical Overlay)
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #FF5500"></div> Marine Traffic (AIS)
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #00AAFF"></div> Weather & Wind
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #FF0000"></div> Navigational Warnings
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #3d83b3"></div> Bathymetry (Depth Contours)
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js" crossorigin=""></script>
  <script>
    const API_CONFIG = {
      local: 'http://localhost:3000',
      production: 'https://shipcleaninggis-server.onrender.com',
      mockMode: false
    };

    const apiBaseUrl = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' ? API_CONFIG.local : API_CONFIG.production;

    let map;
    let currentMarker = null;
    let tempClickLocation = null;

    const govLayers = {
      portAuthorities: { url: `/api/portAuthorities`, style: { color: '#FF4081', weight: 2, opacity: 0.8, fillOpacity: 0.2 }, layer: null },
      marineParks: { url: `/api/marineParks`, style: { color: '#4CAF50', weight: 2, opacity: 0.8, fillOpacity: 0.2 }, layer: null },
      fishHabitat: { url: `/api/fishHabitat`, style: { color: '#FF9800', weight: 2, opacity: 0.8, fillOpacity: 0.2 }, layer: null },
      cockburnSound: { url: `/api/cockburnSound`, style: { color: '#2196F3', weight: 2, opacity: 0.8, fillOpacity: 0.2 }, layer: null },
      mooringAreas: { url: `/api/mooringAreas`, style: { color: '#9C27B0', weight: 2, opacity: 0.8, fillOpacity: 0.2 }, layer: null },
      marineInfrastructure: { url: `/api/marineInfrastructure`, style: { color: '#795548', weight: 2, opacity: 0.8, fillOpacity: 0.2 }, layer: null },
      recommendedZones: { url: `/api/recommendedZones`, style: { color: '#673AB7', weight: 2, opacity: 0.8, fillOpacity: 0.2 }, layer: null }
    };

    const layerColors = {
      portAuthorities: '#FF4081',
      marineParks: '#4CAF50',
      fishHabitat: '#FF9800',
      cockburnSound: '#2196F3',
      mooringAreas: '#9C27B0',
      marineInfrastructure: '#795548',
      recommendedZones: '#673AB7'
    };

    function showError(message, duration = 5000) {
      const toast = document.getElementById('errorToast');
      toast.textContent = message;
      toast.style.display = 'block';
      setTimeout(() => toast.style.display = 'none', duration);
    }

    function updateLayerLoadingState(key, isLoading) {
      const control = document.querySelector(`#${key}Checkbox`);
      if (control) {
        const parent = control.closest('.layer-control');
        if (parent) parent.classList.toggle('layer-control-loading', isLoading);
      }
    }

    async function fetchWithRetry(url, key, retries = 5) {
      const timeoutDuration = key === 'recommendedZones' ? 60000 : 30000;
      for (let i = 0; i < retries; i++) {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeoutDuration);
          const response = await fetch(url, { signal: controller.signal });
          clearTimeout(timeoutId);
          if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
          return await response.json();
        } catch (error) {
          if (i === retries - 1) {
            console.error(`Failed to fetch ${key} after ${retries} attempts: ${error.message}`);
            throw error;
          }
          console.log(`Retry ${i + 1}/${retries} for ${key}`);
          await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i)));
        }
      }
    }

    async function fetchLayerData(url, key) {
      try {
        const fetchUrl = url.startsWith('http') ? url : `${apiBaseUrl}${url}`;
        console.log(`Fetching data from: ${fetchUrl}`);
        const data = await fetchWithRetry(fetchUrl, key);
        return data;
      } catch (error) {
        console.error(`Error fetching ${key}:`, error);
        if (key === 'recommendedZones') {
          console.warn(`Using fallback for ${key}: ${error.message}`);
          return {
            type: 'FeatureCollection',
            features: [{
              type: 'Feature',
              properties: { type: 'Potential Cleaning Zone (Client Fallback)', description: 'Fallback - server unavailable' },
              geometry: { type: 'Polygon', coordinates: [[[115.65, -32.02], [115.68, -32.02], [115.68, -31.98], [115.65, -31.98], [115.65, -32.02]]] }
            }]
          };
        }
        throw error;
      }
    }

    async function analyzeLocation(lat, lng) {
      try {
        document.getElementById('loadingMessage').textContent = 'Analyzing location...';
        document.getElementById('loadingOverlay').style.display = 'flex';

        if (currentMarker) map.removeLayer(currentMarker);

        const markerHtml = `<div class="analysis-marker">?</div>`;
        const icon = L.divIcon({ html: markerHtml, className: '', iconSize: [30, 30], iconAnchor: [15, 15] });
        currentMarker = L.marker([lat, lng], { icon }).addTo(map);

        const analyzeUrl = `${apiBaseUrl}/api/analyzeProximity`;
        console.log(`Sending analysis request to: ${analyzeUrl}`);

        const response = await fetch(analyzeUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ lat, lng })
        });

        if (!response.ok) throw new Error(`Analysis request failed: ${response.statusText}`);

        const data = await response.json();
        displayAnalysisResults(data);
      } catch (error) {
        console.error('Analysis error:', error);
        showError(`Failed to analyze location: ${error.message}`);
      } finally {
        document.getElementById('loadingOverlay').style.display = 'none';
      }
    }

    function displayAnalysisResults(data) {
      const container = document.getElementById('analysisContainer');
      const content = document.getElementById('analysisContent');
      content.innerHTML = '';

      const locationInfo = document.createElement('div');
      locationInfo.innerHTML = `<strong>Coordinates:</strong> ${data.coordinates.lat.toFixed(5)}, ${data.coordinates.lng.toFixed(5)}`;
      content.appendChild(locationInfo);

      if (data.results.nauticalReferences) {
        const nauticalDiv = document.createElement('div');
        nauticalDiv.className = 'analysis-item';
        let nauticalHTML = `
          <div class="analysis-header">
            <div class="analysis-icon" style="background: #0066CC"></div>
            <div class="analysis-title">Nautical References</div>
          </div>
          <div class="analysis-detail">
        `;
        Object.entries(data.results.nauticalReferences).forEach(([name, info]) => {
          nauticalHTML += `
            <p><strong>${name}</strong> (${info.type}): 
               ${info.distance} km ${info.bearingText} (${info.bearing}¬∞)
               <br><small>${info.description}</small>
            </p>
          `;
        });
        nauticalHTML += `</div>`;
        nauticalDiv.innerHTML = nauticalHTML;
        content.appendChild(nauticalDiv);
      }

      if (data.results.recommendedZone) {
        const recommendationDiv = document.createElement('div');
        recommendationDiv.className = 'analysis-item';
        if (data.results.recommendedZone.error) {
          recommendationDiv.innerHTML = `
            <div class="analysis-header">
              <div class="analysis-icon" style="background: ${layerColors.recommendedZones}"></div>
              <div class="analysis-title">Site Suitability</div>
            </div>
            <div class="analysis-detail">
              <p class="analysis-warning">Unable to determine if this location is in a recommended zone.</p>
            </div>
          `;
        } else {
          const isRecommended = data.results.recommendedZone.insideRecommendedZone;
          recommendationDiv.innerHTML = `
            <div class="analysis-header">
              <div class="analysis-icon" style="background: ${layerColors.recommendedZones}"></div>
              <div class="analysis-title">Site Suitability</div>
            </div>
            <div class="analysis-detail">
              <p class="${isRecommended ? 'analysis-good' : 'analysis-warning'}">
                This location is ${isRecommended ? '' : 'NOT '}within a recommended cleaning zone.
              </p>
            </div>
          `;
        }
        content.appendChild(recommendationDiv);
      }

      const constraints = Object.entries(data.results).filter(([key]) => key !== 'recommendedZone' && key !== 'nauticalReferences');
      for (const [key, result] of constraints) {
        const constraintDiv = document.createElement('div');
        constraintDiv.className = 'analysis-item';
        const constraintName = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());

        if (result.error || result.status) {
          constraintDiv.innerHTML = `
            <div class="analysis-header">
              <div class="analysis-icon" style="background: ${layerColors[key] || '#666'}"></div>
              <div class="analysis-title">${constraintName}</div>
            </div>
            <div class="analysis-detail">
              <p>No proximity data available: ${result.error || result.status}</p>
            </div>
          `;
        } else {
          const isInside = result.insideFeature === true;
          const isClose = !isInside && result.distance && parseFloat(result.distance) < 1.0;
          const statusClass = isInside || isClose ? 'analysis-warning' : 'analysis-good';
          const statusText = isInside ? `Inside ${result.featureName}` :
            isClose ? `Close to ${result.featureName} (${result.distance} km)` :
              `${result.distance} km from nearest ${result.featureName}`;
          constraintDiv.innerHTML = `
            <div class="analysis-header">
              <div class="analysis-icon" style="background: ${layerColors[key] || '#666'}"></div>
              <div class="analysis-title">${constraintName}</div>
            </div>
            <div class="analysis-detail">
              <p class="${statusClass}">${statusText}</p>
            </div>
          `;
        }
        content.appendChild(constraintDiv);
      }

      container.style.display = 'block';
    }

    function updateRecommendedZonesLayer(geojson) {
      try {
        if (govLayers.recommendedZones.layer) map.removeLayer(govLayers.recommendedZones.layer);

        govLayers.recommendedZones.layer = L.geoJSON(geojson, {
          style: govLayers.recommendedZones.style,
          onEachFeature: (feature, layer) => {
            if (feature.properties) {
              let popupContent = feature.properties.description && feature.properties.description.includes('Fallback') ?
                '<strong>Note:</strong> Using simplified zone data.<br><br>' : '';
              popupContent += Object.entries(feature.properties)
                .map(([prop, value]) => `<strong>${prop}:</strong> ${value}`)
                .join('<br>');
              layer.bindPopup(popupContent);
            }
          }
        }).addTo(map);

        govLayers.recommendedZones.layer.on('click', e => {
          L.DomEvent.stopPropagation(e);
          tempClickLocation = e.latlng;
          document.getElementById('confirmationModal').style.display = 'block';
        });

        const checkbox = document.getElementById('recommendedZonesCheckbox');
        if (checkbox) {
          checkbox.checked = true;
          checkbox.addEventListener('change', e => {
            e.target.checked ? map.addLayer(govLayers.recommendedZones.layer) : map.removeLayer(govLayers.recommendedZones.layer);
          });
        }

        updateLayerLoadingState('recommendedZones', false);
        return true;
      } catch (error) {
        console.error('Error updating recommendedZones layer:', error);
        updateLayerLoadingState('recommendedZones', false);
        return false;
      }
    }

    function loadRecommendedZones() {
      updateLayerLoadingState('recommendedZones', true);
      document.getElementById('loadingMessage').textContent = 'Loading potential cleaning zones...';
      document.getElementById('loadingOverlay').style.display = 'flex';

      return fetchLayerData(govLayers.recommendedZones.url, 'recommendedZones')
        .then(geojson => {
          updateRecommendedZonesLayer(geojson);
          document.getElementById('loadingOverlay').style.display = 'none';
        })
        .catch(err => {
          console.error(`Error loading recommendedZones: ${err}`);
          showError('Failed to load detailed cleaning zones. Using simplified version.');
          const fallbackGeoJSON = {
            type: 'FeatureCollection',
            features: [{
              type: 'Feature',
              properties: { type: 'Potential Cleaning Zone (Fallback)', description: 'Simplified zone' },
              geometry: { type: 'Polygon', coordinates: [[[115.65, -32.02], [115.68, -32.02], [115.68, -31.98], [115.65, -31.98], [115.65, -32.02]]] }
            }]
          };
          updateRecommendedZonesLayer(fallbackGeoJSON);
          document.getElementById('loadingOverlay').style.display = 'none';
        });
    }

    async function createSeaMarksLayer() {
      try {
        updateLayerLoadingState('seaMarks', true);
        const seamarkUrls = [
          'https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png',
          'https://t1.openseamap.org/seamark/{z}/{x}/{y}.png',
          'https://map.openseamap.org/seamark/{z}/{x}/{y}.png'
        ];

        const testTileUrl = async url => {
          try {
            const testUrl = url.replace('{z}/{x}/{y}', '10/529/336');
            const response = await fetch(testUrl, { method: 'HEAD', timeout: 3000 });
            return response.ok;
          } catch {
            return false;
          }
        };

        for (const url of seamarkUrls) {
          if (await testTileUrl(url)) {
            console.log(`Using sea marks from: ${url}`);
            return L.tileLayer(url, { maxZoom: 19, attribution: 'Sea Marks ¬© <a href="http://www.openseamap.org">OpenSeaMap</a>' });
          }
        }

        console.log("All sea mark tile sources failed, using fallback");
        return createFallbackSeaMarks();
      } catch (error) {
        console.error('Error creating sea marks layer:', error);
        return createFallbackSeaMarks();
      } finally {
        updateLayerLoadingState('seaMarks', false);
      }
    }

    function createFallbackSeaMarks() {
      const layer = L.layerGroup();
      const navAids = [
        { pos: [-32.045, 115.730], type: 'lighthouse', name: 'Fremantle Lighthouse', icon: 'üóº' },
        { pos: [-32.053, 115.742], type: 'buoy', name: 'Entrance Channel Buoy (Port)', icon: 'üî¥' },
        { pos: [-32.053, 115.738], type: 'buoy', name: 'Entrance Channel Buoy (Starboard)', icon: 'üü¢' },
        { pos: [-32.042, 115.725], type: 'beacon', name: 'Navigation Beacon', icon: 'üö®' },
        { pos: [-32.030, 115.710], type: 'anchorage', name: 'Designated Anchorage', icon: '‚öì' }
      ];

      navAids.forEach(aid => {
        const marker = L.marker(aid.pos, {
          icon: L.divIcon({ html: `<div style="font-size: 24px;">${aid.icon}</div>`, className: 'sea-mark-icon', iconSize: [30, 30], iconAnchor: [15, 15] })
        }).bindPopup(`<b>${aid.name}</b><br>Type: ${aid.type}`);
        layer.addLayer(marker);
      });

      return layer;
    }

    function createMarineTrafficLayer() {
      const layer = L.layerGroup();
      const vessels = [
        { pos: [-32.025, 115.710], name: 'Cargo Vessel', type: 'cargo', heading: 45, speed: 12, icon: 'üö¢' },
        { pos: [-32.040, 115.690], name: 'Oil Tanker', type: 'tanker', heading: 180, speed: 8, icon: 'üõ≥Ô∏è' },
        { pos: [-32.055, 115.705], name: 'Passenger Ferry', type: 'passenger', heading: 270, speed: 15, icon: 'üö¢' },
        { pos: [-32.035, 115.725], name: 'Fishing Vessel', type: 'fishing', heading: 90, speed: 5, icon: 'üö£' },
        { pos: [-32.015, 115.745], name: 'Navy Vessel', type: 'military', heading: 135, speed: 18, icon: '‚öì' }
      ];

      vessels.forEach(vessel => {
        const marker = L.marker(vessel.pos, {
          icon: L.divIcon({
            html: `<div style="font-size: 20px; transform: rotate(${vessel.heading}deg);">${vessel.icon}</div>`,
            className: 'vessel-icon',
            iconSize: [30, 30],
            iconAnchor: [15, 15]
          })
        }).bindPopup(`
          <b>${vessel.name}</b><br>
          Type: ${vessel.type}<br>
          Heading: ${vessel.heading}¬∞<br>
          Speed: ${vessel.speed} knots
        `);
        layer.addLayer(marker);

        const trackLine = L.polyline([
          vessel.pos,
          [vessel.pos[0] - Math.sin(vessel.heading * Math.PI / 180) * 0.01,
          vessel.pos[1] - Math.cos(vessel.heading * Math.PI / 180) * 0.01]
        ], {
          color: '#FF5500',
          weight: 2,
          opacity: 0.7,
          dashArray: '5, 5'
        });
        layer.addLayer(trackLine);
      });

      return layer;
    }

    function createWeatherLayer() {
      const layer = L.layerGroup();
      const stations = [
        { pos: [-32.030, 115.730], temp: 21, wind_speed: 15, wind_dir: 'NW', pressure: 1013 },
        { pos: [-32.060, 115.700], temp: 20, wind_speed: 12, wind_dir: 'W', pressure: 1012 },
        { pos: [-32.010, 115.760], temp: 22, wind_speed: 8, wind_dir: 'SW', pressure: 1014 }
      ];

      stations.forEach(station => {
        const marker = L.marker(station.pos, {
          icon: L.divIcon({
            html: `<div style="font-size: 24px; color: #00AAFF;">üå§Ô∏è</div>`,
            className: 'weather-icon',
            iconSize: [30, 30],
            iconAnchor: [15, 15]
          })
        }).bindPopup(`
          <b>Weather Station</b><br>
          Temperature: ${station.temp}¬∞C<br>
          Wind: ${station.wind_speed} knots ${station.wind_dir}<br>
          Pressure: ${station.pressure} hPa
        `);
        layer.addLayer(marker);

        const dirMap = { 'N': 0, 'NE': 45, 'E': 90, 'SE': 135, 'S': 180, 'SW': 225, 'W': 270, 'NW': 315 };
        const dir = dirMap[station.wind_dir] || 0;
        const arrow = L.marker(station.pos, {
          icon: L.divIcon({
            html: `<div style="font-size: 20px; transform: rotate(${dir}deg);">‚û°Ô∏è</div>`,
            className: 'wind-direction',
            iconSize: [20, 20],
            iconAnchor: [10, 30]
          })
        });
        layer.addLayer(arrow);
      });

      for (let lat = -32.01; lat >= -32.08; lat -= 0.02) {
        for (let lng = 115.68; lng <= 115.78; lng += 0.02) {
          const baseDir = 315;
          const variation = Math.floor(Math.random() * 30) - 15;
          const direction = baseDir + variation;
          const arrow = L.marker([lat, lng], {
            icon: L.divIcon({
              html: `<div style="font-size: 12px; color: #00AAFF; transform: rotate(${direction}deg);">‚û°Ô∏è</div>`,
              className: 'wind-pattern',
              iconSize: [15, 15],
              iconAnchor: [7.5, 7.5]
            })
          });
          layer.addLayer(arrow);
        }
      }

      return layer;
    }

    function createNavigationalWarningsLayer() {
      const layer = L.layerGroup();
      const warnings = [
        {
          pos: [-32.040, 115.725],
          title: 'Navigation Hazard',
          details: 'Submerged object reported in this area. Exercise caution.',
          type: 'hazard',
          polygon: [[-32.035, 115.720], [-32.030, 115.730], [-32.045, 115.735], [-32.050, 115.725], [-32.035, 115.720]]
        },
        {
          pos: [-32.060, 115.760],
          title: 'Restricted Area',
          details: 'Naval exercise zone active from June 1-5. All vessels prohibited.',
          type: 'restricted',
          polygon: [[-32.055, 115.755], [-32.050, 115.765], [-32.065, 115.770], [-32.070, 115.760], [-32.055, 115.755]]
        },
        {
          pos: [-32.025, 115.695],
          title: 'Strong Currents',
          details: 'Strong tidal currents reported in this area. Small vessels use caution.',
          type: 'current',
          radius: 0.005
        }
      ];

      warnings.forEach(warning => {
        const marker = L.marker(warning.pos, {
          icon: L.divIcon({
            html: `<div style="font-size: 24px; color: #FF0000;">‚ö†Ô∏è</div>`,
            className: 'warning-icon',
            iconSize: [30, 30],
            iconAnchor: [15, 15]
          })
        }).bindPopup(`
          <b>${warning.title}</b><br>
          ${warning.details}
        `);
        layer.addLayer(marker);

        if (warning.polygon) {
          const polygon = L.polygon(warning.polygon, {
            color: '#FF0000',
            weight: 2,
            opacity: 0.6,
            fillColor: '#FF0000',
            fillOpacity: 0.1,
            dashArray: '5, 5'
          }).bindPopup(`
            <b>${warning.title}</b><br>
            ${warning.details}
          `);
          layer.addLayer(polygon);
        } else if (warning.radius) {
          const circle = L.circle(warning.pos, {
            radius: warning.radius * 111319.9,
            color: '#FF0000',
            weight: 2,
            opacity: 0.6,
            fillColor: '#FF0000',
            fillOpacity: 0.1,
            dashArray: '5, 5'
          }).bindPopup(`
            <b>${warning.title}</b><br>
            ${warning.details}
          `);
          layer.addLayer(circle);
        }
      });

      return layer;
    }

    function createBathymetryLayer() {
      const layer = L.layerGroup();
      const depthContours = [
        { depth: 5, color: '#77c3ec', points: [[-32.045, 115.735], [-32.050, 115.745], [-32.060, 115.750], [-32.070, 115.745], [-32.075, 115.735], [-32.045, 115.735]] },
        { depth: 10, color: '#5ba3d0', points: [[-32.040, 115.730], [-32.045, 115.740], [-32.055, 115.745], [-32.065, 115.740], [-32.070, 115.730], [-32.040, 115.730]] }
      ];

      depthContours.forEach(contour => {
        const polyline = L.polyline(contour.points, { color: contour.color, weight: 2, opacity: 0.8, smoothFactor: 1 }).bindTooltip(`${contour.depth}m depth`, { sticky: true });
        layer.addLayer(polyline);

        contour.points.forEach((point, index) => {
          if (index % 2 === 0 && index < contour.points.length - 1) {
            const label = L.marker(point, {
              icon: L.divIcon({ html: `<div style="color: ${contour.color}; font-size: 10px; font-weight: bold;">${contour.depth}m</div>`, className: 'depth-label', iconSize: [30, 10], iconAnchor: [15, 5] })
            });
            layer.addLayer(label);
          }
        });
      });

      return layer;
    }

    function addCompassRose() {
      const compassRose = L.control({ position: 'bottomleft' });
      compassRose.onAdd = function () {
        const div = L.DomUtil.create('div', 'compass-rose');
        div.innerHTML = `
          <svg width="100" height="100" viewBox="0 0 100 100">
            <circle cx="50" cy="50" r="45" fill="white" fill-opacity="0.7" stroke="#333" stroke-width="1" />
            <path d="M50,5 L55,45 L50,50 L45,45 Z" fill="#D32F2F" stroke="#333" stroke-width="0.5" />
            <path d="M50,95 L55,55 L50,50 L45,55 Z" fill="#333" stroke="#333" stroke-width="0.5" />
            <path d="M5,50 L45,45 L50,50 L45,55 Z" fill="#333" stroke="#333" stroke-width="0.5" />
            <path d="M95,50 L55,45 L50,50 L55,55 Z" fill="#333" stroke="#333" stroke-width="0.5" />
            <text x="50" y="20" text-anchor="middle" font-size="12" font-weight="bold">N</text>
            <text x="50" y="85" text-anchor="middle" font-size="12" font-weight="bold">S</text>
            <text x="85" y="52" text-anchor="middle" font-size="12" font-weight="bold">E</text>
            <text x="15" y="52" text-anchor="middle" font-size="12" font-weight="bold">W</text>
          </svg>
        `;
        return div;
      };
      compassRose.addTo(map);
    }

    async function initMap() {
      try {
        map = L.map('map').setView([-32.05, 115.73], 12);

        const thunderforestApiKey = '992545b83c194d0c926906e029791e42';
        const baseLayers = {
          openStreetMap: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '¬© OpenStreetMap contributors'
          }),
          thunderforestCycle: L.tileLayer(`https://tile.thunderforest.com/cycle/{z}/{x}/{y}.png?apikey=${thunderforestApiKey}`, {
            maxZoom: 19,
            attribution: 'Maps ¬© <a href="https://www.thunderforest.com">Thunderforest</a>, Data ¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap contributors</a>'
          }),
          thunderforestTransport: L.tileLayer(`https://tile.thunderforest.com/transport/{z}/{x}/{y}.png?apikey=${thunderforestApiKey}`, {
            maxZoom: 19,
            attribution: 'Maps ¬© <a href="https://www.thunderforest.com">Thunderforest</a>, Data ¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap contributors</a>'
          }),
          thunderforestLandscape: L.tileLayer(`https://tile.thunderforest.com/landscape/{z}/{x}/{y}.png?apikey=${thunderforestApiKey}`, {
            maxZoom: 19,
            attribution: 'Maps ¬© <a href="https://www.thunderforest.com">Thunderforest</a>, Data ¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap contributors</a>'
          }),
          thunderforestOutdoors: L.tileLayer(`https://tile.thunderforest.com/outdoors/{z}/{x}/{y}.png?apikey=${thunderforestApiKey}`, {
            maxZoom: 19,
            attribution: 'Maps ¬© <a href="https://www.thunderforest.com">Thunderforest</a>, Data ¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap contributors</a>'
          }),
          thunderforestTransportDark: L.tileLayer(`https://tile.thunderforest.com/transport-dark/{z}/{x}/{y}.png?apikey=${thunderforestApiKey}`, {
            maxZoom: 19,
            attribution: 'Maps ¬© <a href="https://www.thunderforest.com">Thunderforest</a>, Data ¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap contributors</a>'
          }),
          thunderforestSpinalMap: L.tileLayer(`https://tile.thunderforest.com/spinal-map/{z}/{x}/{y}.png?apikey=${thunderforestApiKey}`, {
            maxZoom: 19,
            attribution: 'Maps ¬© <a href="https://www.thunderforest.com">Thunderforest</a>, Data ¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap contributors</a>'
          }),
          thunderforestPioneer: L.tileLayer(`https://tile.thunderforest.com/pioneer/{z}/{x}/{y}.png?apikey=${thunderforestApiKey}`, {
            maxZoom: 19,
            attribution: 'Maps ¬© <a href="https://www.thunderforest.com">Thunderforest</a>, Data ¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap contributors</a>'
          }),
          thunderforestMobileAtlas: L.tileLayer(`https://tile.thunderforest.com/mobile-atlas/{z}/{x}/{y}.png?apikey=${thunderforestApiKey}`, {
            maxZoom: 19,
            attribution: 'Maps ¬© <a href="https://www.thunderforest.com">Thunderforest</a>, Data ¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap contributors</a>'
          }),
          thunderforestNeighbourhood: L.tileLayer(`https://tile.thunderforest.com/neighbourhood/{z}/{x}/{y}.png?apikey=${thunderforestApiKey}`, {
            maxZoom: 19,
            attribution: 'Maps ¬© <a href="https://www.thunderforest.com">Thunderforest</a>, Data ¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap contributors</a>'
          }),
          thunderforestAtlas: L.tileLayer(`https://tile.thunderforest.com/atlas/{z}/{x}/{y}.png?apikey=${thunderforestApiKey}`, {
            maxZoom: 19,
            attribution: 'Maps ¬© <a href="https://www.thunderforest.com">Thunderforest</a>, Data ¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap contributors</a>'
          }),
          esriOceanBase: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Ocean_Basemap/MapServer/tile/{z}/{y}/{x}', {
            maxZoom: 19,
            attribution: 'Tiles ¬© Esri ‚Äî Sources: GEBCO, NOAA, CHS, OSU, UNH, CSUMB, National Geographic, DeLorme, NAVTEQ, and Esri'
          }),
          openSeaMapBase: L.tileLayer('https://tiles.openseamap.org/base/{z}/{x}/{y}.png', {
            maxZoom: 18,
            attribution: 'Map data: ¬© <a href="http://www.openseamap.org">OpenSeaMap</a> contributors'
          }),
          noaaCharts: L.tileLayer('https://tileservice.charts.noaa.gov/tiles/50000_1/{z}/{x}/{y}.png', {
            maxZoom: 18,
            opacity: 0.8,
            attribution: 'NOAA Charts - <a href="https://charts.noaa.gov/">Office of Coast Survey</a>'
          })
        };

        baseLayers.esriOceanBase.addTo(map);

        const layerControl = L.control.layers({
          "OpenStreetMap": baseLayers.openStreetMap,
          "Thunderforest Cycle": baseLayers.thunderforestCycle,
          "Thunderforest Transport": baseLayers.thunderforestTransport,
          "Thunderforest Landscape": baseLayers.thunderforestLandscape,
          "Thunderforest Outdoors": baseLayers.thunderforestOutdoors,
          "Thunderforest Transport Dark": baseLayers.thunderforestTransportDark,
          "Thunderforest Spinal Map": baseLayers.thunderforestSpinalMap,
          "Thunderforest Pioneer": baseLayers.thunderforestPioneer,
          "Thunderforest Mobile Atlas": baseLayers.thunderforestMobileAtlas,
          "Thunderforest Neighbourhood": baseLayers.thunderforestNeighbourhood,
          "Thunderforest Atlas": baseLayers.thunderforestAtlas,
          "ESRI Ocean Base": baseLayers.esriOceanBase,
          "OpenSeaMap Base": baseLayers.openSeaMapBase,
          "NOAA Charts": baseLayers.noaaCharts
        }, null, { position: 'topleft', collapsed: false }).addTo(map);

        const nauticalOverlays = {};

        map.on('click', e => {
          tempClickLocation = e.latlng;
          document.getElementById('confirmationModal').style.display = 'block';
        });

        document.getElementById('confirmYes').addEventListener('click', () => {
          if (tempClickLocation) {
            document.getElementById('confirmationModal').style.display = 'none';
            analyzeLocation(tempClickLocation.lat, tempClickLocation.lng);
          }
        });

        document.getElementById('confirmNo').addEventListener('click', () => {
          document.getElementById('confirmationModal').style.display = 'none';
          tempClickLocation = null;
          if (currentMarker) {
            map.removeLayer(currentMarker);
            currentMarker = null;
          }
        });

        document.getElementById('analysisClose').addEventListener('click', () => {
          document.getElementById('analysisContainer').style.display = 'none';
          if (currentMarker) {
            map.removeLayer(currentMarker);
            currentMarker = null;
          }
        });

        const loadPromises = Object.keys(govLayers)
          .filter(key => key !== 'recommendedZones')
          .map(key => {
            updateLayerLoadingState(key, true);
            document.getElementById('loadingMessage').textContent = `Loading ${key.replace(/([A-Z])/g, ' $1').toLowerCase()}...`;
            return fetchLayerData(govLayers[key].url, key)
              .then(geojson => {
                govLayers[key].layer = L.geoJSON(geojson, {
                  style: govLayers[key].style,
                  onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                      const popupContent = Object.entries(feature.properties)
                        .map(([prop, value]) => `<strong>${prop}:</strong> ${value}`)
                        .join('<br>');
                      layer.bindPopup(popupContent);
                    }
                  }
                }).addTo(map);

                govLayers[key].layer.on('click', e => {
                  L.DomEvent.stopPropagation(e);
                  tempClickLocation = e.latlng;
                  document.getElementById('confirmationModal').style.display = 'block';
                });

                const checkbox = document.getElementById(key + 'Checkbox');
                if (checkbox) {
                  checkbox.addEventListener('change', e => {
                    e.target.checked ? map.addLayer(govLayers[key].layer) : map.removeLayer(govLayers[key].layer);
                  });
                }

                updateLayerLoadingState(key, false);
              })
              .catch(err => {
                console.error(`Error loading ${key}:`, err);
                showError(`Failed to load ${key}. Please try refreshing the page.`);
                updateLayerLoadingState(key, false);
              });
          });

        loadPromises.push(loadRecommendedZones());
        await Promise.allSettled(loadPromises);

        const seaMarksLayer = await createSeaMarksLayer();
        if (seaMarksLayer) {
          nauticalOverlays['Sea Marks'] = seaMarksLayer;
          layerControl.addOverlay(seaMarksLayer, 'Sea Marks');
          const seaMarksCheckbox = document.getElementById('seaMarksCheckbox');
          if (seaMarksCheckbox && seaMarksCheckbox.checked) seaMarksLayer.addTo(map);
          seaMarksCheckbox.addEventListener('change', e => e.target.checked ? map.addLayer(seaMarksLayer) : map.removeLayer(seaMarksLayer));
        }

        const marineTrafficLayer = createMarineTrafficLayer();
        nauticalOverlays['Marine Traffic'] = marineTrafficLayer;
        layerControl.addOverlay(marineTrafficLayer, 'Marine Traffic (AIS)');
        const marineTrafficCheckbox = document.getElementById('marineTrafficCheckbox');
        if (marineTrafficCheckbox) {
          if (marineTrafficCheckbox.checked) marineTrafficLayer.addTo(map);
          marineTrafficCheckbox.addEventListener('change', e => e.target.checked ? map.addLayer(marineTrafficLayer) : map.removeLayer(marineTrafficLayer));
        }

        const weatherLayer = createWeatherLayer();
        nauticalOverlays['Weather'] = weatherLayer;
        layerControl.addOverlay(weatherLayer, 'Weather & Wind');
        const weatherCheckbox = document.getElementById('weatherCheckbox');
        if (weatherCheckbox) {
          if (weatherCheckbox.checked) weatherLayer.addTo(map);
          weatherCheckbox.addEventListener('change', e => e.target.checked ? map.addLayer(weatherLayer) : map.removeLayer(weatherLayer));
        }

        const navWarningsLayer = createNavigationalWarningsLayer();
        nauticalOverlays['Navigational Warnings'] = navWarningsLayer;
        layerControl.addOverlay(navWarningsLayer, 'Navigational Warnings');
        const navWarningsCheckbox = document.getElementById('navigationalWarningsCheckbox');
        if (navWarningsCheckbox) {
          if (navWarningsCheckbox.checked) navWarningsLayer.addTo(map);
          navWarningsCheckbox.addEventListener('change', e => e.target.checked ? map.addLayer(navWarningsLayer) : map.removeLayer(navWarningsLayer));
        }

        const bathymetryLayer = createBathymetryLayer();
        nauticalOverlays['Bathymetry'] = bathymetryLayer;
        layerControl.addOverlay(bathymetryLayer, 'Bathymetry (Depth Contours)');
        const bathymetryCheckbox = document.getElementById('bathymetryCheckbox');
        if (bathymetryCheckbox && bathymetryCheckbox.checked) bathymetryLayer.addTo(map);
        bathymetryCheckbox.addEventListener('change', e => e.target.checked ? map.addLayer(bathymetryLayer) : map.removeLayer(bathymetryLayer));

        addCompassRose();

        setTimeout(() => {
          map.invalidateSize();
          map.fitBounds([[-32.15, 115.65], [-31.95, 115.85]]);
        }, 200);
      } catch (error) {
        console.error('Map initialization error:', error);
        showError(`Failed to initialize map: ${error.message}`);
      } finally {
        setTimeout(() => document.getElementById('loadingOverlay').style.display = 'none', 1000);
      }
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initMap);
    } else {
      initMap();
    }
  </script>
</body>

</html>